# RFC-0004: Projection and Memory Formal Model

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2025-03-01
**Last Updated**: 2025-03-01
**Depends on**: [RFC-0001](RFC-0001.md), [RFC-0002](RFC-0002.md), [RFC-0003](RFC-0003.md)
**Supersedes**: ---
**Kind**: Architecture Design

---

## 1. Abstract

This RFC defines the **formal model for Projection and Memory** in the Noesium multi-agent system. It establishes:

* A **mathematical model** for event-sourced projections
* A **typed memory hierarchy** (ephemeral, durable, semantic)
* Deterministic projection constraints aligned with RFC-0003
* A separation between **execution state** and **cognitive memory**
* Compositional rules for multi-agent memory interaction

The goal is to ensure that memory in Noesium is:

* Deterministic where required
* Event-sourced and replayable
* Isolated yet composable
* Extensible to semantic/vector systems
* Auditable and reproducible

---

## 2. Design Principles

1. **Memory is derived, not mutated.**
2. **Projections are pure functions over event streams.**
3. **Semantic memory is an index, not a source of truth.**
4. **Execution determinism must not depend on nondeterministic memory retrieval.**
5. **All durable state must be reconstructable from events.**

---

## 3. Terminology

| Term             | Definition                                 |
| ---------------- | ------------------------------------------ |
| Event            | Immutable fact defined in RFC-0002         |
| Stream           | Ordered sequence of events                 |
| Projection       | Deterministic fold over event stream       |
| Snapshot         | Materialized state derived from projection |
| Memory           | Structured state derived from events       |
| Kernel State     | Deterministic execution state (RFC-0003)   |
| Cognitive Memory | Agent knowledge layer                      |

---

## 4. Formal Model

### 4.1 Event Stream

Let:

E = set of all valid events
S = ordered sequence of events

For a given agent `A`:

```
S_A = [e1, e2, e3, ..., en]
```

Each event must satisfy:

* Strict ordering (Lamport or vector clock)
* Immutable payload
* Versioned schema

---

### 4.2 Projection Function

A projection is defined as:

```
P : (State, Event) → State
```

And the materialized state after n events:

```
State_n = fold(P, State_0, S[0:n])
```

Constraints:

* P must be pure
* P must be deterministic
* P must not perform external IO
* P must not invoke LLM inference

This guarantees replayability.

---

### 4.3 Projection Categories

#### 4.3.1 Execution Projection (Deterministic)

Used by Kernel.

Examples:

* Workflow state
* Task graph
* Agent lifecycle state
* Retry counters
* Circuit breaker status

Properties:

* Must be replayable bit-for-bit
* Cannot depend on semantic similarity
* Cannot depend on time.now()
* Cannot depend on randomness

---

#### 4.3.2 Cognitive Projection (Deterministic Structural)

Derived from events but may structure knowledge.

Examples:

* Conversation history
* Tool usage history
* Plan evolution
* Agent reasoning trace

Still pure functions.

---

#### 4.3.3 Semantic Projection (Indexed)

Constructed from deterministic projection output.

```
SemanticIndex = Index(State_n)
```

Important distinction:

* Index is derived artifact
* Not authoritative source of truth
* Rebuildable from deterministic projection

---

## 5. Memory Hierarchy

Noesium defines three memory layers:

---

### 5.1 Ephemeral Memory (Session Scope)

* Exists during a single kernel execution
* Not persisted as authoritative state
* Derived from durable projections
* Cleared on restart

Use cases:

* In-flight reasoning context
* Temporary planning variables
* Short-lived tool outputs

---

### 5.2 Durable Memory (Event-Sourced)

Canonical memory layer.

Includes:

* Agent configuration
* Task history
* Structured knowledge
* User interaction history
* Decision traces

Storage form:

```
Events → Projection → Snapshot
```

Never:

```
Direct mutation → DB write
```

---

### 5.3 Semantic Memory (Indexed Retrieval)

Derived layer:

```
Durable Projection → Embedding → Vector Index
```

Properties:

* Rebuildable
* Eventually consistent
* Not required for determinism
* May be sharded or externalized

If semantic store is corrupted:

→ Recompute from event log

---

## 6. Multi-Agent Memory Model

### 6.1 Isolation

Each agent A has:

```
S_A
P_A
State_A
```

No direct state mutation across agents.

---

### 6.2 Shared Memory via Events

Agents communicate only via:

```
Emit(Event) → Bus → Consume(Event)
```

Shared memory is modeled as:

```
S_shared = merge(S_A, S_B, ...)
```

But projection remains local.

---

### 6.3 Federated Projections

Composite projections allowed:

```
P_system = compose(P_A, P_B, ...)
```

Must remain deterministic.

---

## 7. Snapshot Strategy

Snapshots are optimization artifacts.

Rules:

* Must include projection version
* Must include schema version
* Must include last event ID
* Must be discardable

On mismatch:

```
Discard snapshot → Replay events
```

---

## 8. Memory Consistency Model

### 8.1 Strong Consistency

Kernel projections must be strongly consistent with event log.

### 8.2 Eventual Consistency

Semantic index may lag.

### 8.3 Versioned Projection Migration

If projection function changes:

```
P_v1 → P_v2
```

Options:

1. Full replay
2. Migration event
3. Snapshot invalidation

---

## 9. Determinism Boundaries (RFC-0003 Alignment)

Allowed inside projection:

* Pure transformations
* Structural reduction
* Deterministic hashing

Not allowed:

* LLM calls
* Network IO
* Time-based logic
* Random sampling
* External DB queries

LLM interaction must occur:

* In event-producing stage
* Never inside projection fold

---

## 10. Memory Safety Guarantees

This model guarantees:

* Full replayability
* Audit trail completeness
* Cross-version migration safety
* Kernel determinism
* Cognitive traceability
* Rebuildable semantic memory

---

## 11. Failure Modes & Recovery

| Failure             | Recovery                        |
| ------------------- | ------------------------------- |
| Corrupted snapshot  | Replay                          |
| Lost semantic index | Rebuild from durable projection |
| Partial event write | Reject via envelope validation  |
| Projection code bug | Patch → Replay                  |

---

## 12. Open Questions

1. Should semantic projection be versioned independently?
2. Should agents share a global embedding space?
3. How do we bound event log growth?
4. Should cold memory be compacted into summary events?

---

## 13. Future Extensions

* CRDT-based cross-node projections
* Differential memory replay
* Temporal querying (time-travel debugging)
* Memory attestation and cryptographic audit proofs
* Adaptive memory compaction via summarization agents

---

## 14. Conclusion

RFC-0004 formalizes Noesium’s memory architecture as:

* Event-sourced
* Deterministic at its core
* Layered for cognition
* Recoverable by design
* Compatible with semantic retrieval
* Safe for multi-agent composition

This provides a mathematically grounded, replayable, and auditable memory substrate for large-scale multi-agent systems.