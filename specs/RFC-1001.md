# RFC-1001: Core Framework Implementation Design

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: [RFC-0001](RFC-0001.md), [RFC-0002](RFC-0002.md), [RFC-0003](RFC-0003.md), [RFC-0004](RFC-0004.md), [RFC-0005](RFC-0005.md)
**Supersedes**: ---
**Kind**: Implementation Interface Design

---

## 1. Abstract

This RFC defines the concrete Python implementation design for the Noesium core framework. It translates the abstract architectural principles from RFC-0001 through RFC-0005 into specific module structures, class hierarchies, interface contracts, data structures, and configuration patterns. The design targets Python 3.11+ and uses LangGraph as the graph execution substrate, bubus as the in-process event bus, and Pydantic for data modeling.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Module layout and package structure for `noesium/core/`
* Base class hierarchies and abstract interfaces
* Event system implementation (envelope, bus integration, store)
* Projection layer interfaces and implementation patterns
* Memory hierarchy implementation (ephemeral, durable, semantic)
* Capability registry implementation
* Tool system (Toolify) integration with kernel execution
* LLM client abstraction layer
* Configuration management and dependency injection patterns
* Tracing and observability integration

### 2.2 Non-Goals

This RFC does **not** define:

* Specific agent implementations (see [RFC-1002](RFC-1002.md))
* Individual toolkit implementations
* Deployment topology or infrastructure provisioning
* External service integrations (databases, message queues)
* CLI or user-facing application interfaces

---

## 3. Background & Motivation

The Noesium framework currently implements a functional agent system built on LangGraph with direct tool invocation, mutable state management, and in-process event dispatching via bubus. While operational, the current implementation diverges significantly from the event-sourced, deterministic kernel architecture described in RFC-0001 through RFC-0005.

This RFC bridges the gap by defining a concrete implementation path that:

1. Preserves existing working patterns where they align with architectural goals
2. Introduces event-sourced state management incrementally
3. Formalizes the projection layer as the state derivation mechanism
4. Establishes typed capability contracts for inter-agent communication
5. Maintains developer ergonomics while enforcing architectural invariants

---

## 4. Design Principles

1. **Incremental Adoption**: The implementation MUST allow gradual migration from current patterns to full event-sourced execution without breaking existing agents.
2. **Convention over Configuration**: Common patterns SHOULD work with minimal configuration; advanced features activated through explicit opt-in.
3. **Type Safety**: All public interfaces MUST use Pydantic models or typed protocols; runtime type checking via Pydantic validation.
4. **Async First**: Core interfaces MUST be async; synchronous wrappers provided as convenience.
5. **Testability**: All components MUST be injectable and mockable; no hidden global state in core interfaces.

---

## 5. Package Structure

```
noesium/
├── core/
│   ├── __init__.py
│   ├── consts.py                  # Framework constants
│   ├── agent/                     # Agent base classes
│   │   ├── __init__.py
│   │   ├── base.py                # BaseAgent, BaseGraphicAgent
│   │   ├── conversation.py        # BaseHitlAgent
│   │   └── researcher.py          # BaseResearcher
│   ├── event/                     # Event system (RFC-0001, RFC-0002)
│   │   ├── __init__.py
│   │   ├── envelope.py            # EventEnvelope, AgentRef, TraceContext
│   │   ├── store.py               # EventStore interface and implementations
│   │   ├── types.py               # Event type registry, domain event base
│   │   └── codec.py               # Serialization, canonicalization
│   ├── kernel/                    # Deterministic kernel (RFC-0003)
│   │   ├── __init__.py
│   │   ├── executor.py            # KernelExecutor, NodeResult
│   │   ├── checkpoint.py          # Checkpoint management
│   │   └── scheduler.py           # Topological scheduler
│   ├── projection/                # Projection layer (RFC-0004)
│   │   ├── __init__.py
│   │   ├── base.py                # BaseProjection, ProjectionEngine
│   │   ├── execution.py           # ExecutionProjection
│   │   ├── cognitive.py           # CognitiveProjection
│   │   └── semantic.py            # SemanticProjection (index builder)
│   ├── capability/                # Capability registry (RFC-0005)
│   │   ├── __init__.py
│   │   ├── registry.py            # CapabilityRegistry
│   │   ├── discovery.py           # DiscoveryService
│   │   ├── models.py              # Capability, CapabilitySet
│   │   └── resolution.py          # DeterministicResolver
│   ├── llm/                       # LLM integration
│   │   ├── __init__.py
│   │   ├── base.py                # BaseLLMClient
│   │   ├── openai.py
│   │   ├── openrouter.py
│   │   ├── litellm.py
│   │   ├── ollama.py
│   │   └── llamacpp.py
│   ├── memory/                    # Memory hierarchy (RFC-0004)
│   │   ├── __init__.py
│   │   ├── base.py                # BaseMemoryStore, BaseMemoryManager
│   │   ├── models.py              # MemoryItem, MemoryFilter
│   │   ├── ephemeral.py           # EphemeralMemory
│   │   ├── durable.py             # DurableMemory (event-sourced)
│   │   └── memu/                  # Memu subsystem
│   ├── msgbus/                    # Event bus integration
│   │   ├── __init__.py
│   │   ├── base.py                # BaseWatchdog, EventProcessor
│   │   └── bridge.py              # EnvelopeBridge (bubus ↔ EventEnvelope)
│   ├── toolify/                   # Tool system
│   │   ├── __init__.py
│   │   ├── base.py                # BaseToolkit, AsyncBaseToolkit
│   │   ├── config.py              # ToolkitConfig
│   │   ├── registry.py            # ToolkitRegistry
│   │   └── mcp_integration.py     # MCP protocol support
│   ├── goalith/                   # Goal management
│   ├── routing/                   # Model routing
│   ├── tracing/                   # Observability
│   ├── vector_store/              # Vector storage
│   └── utils/                     # Shared utilities
```

### 5.1 New Modules

The following modules are new additions required by the architectural RFCs:

* `core/event/` — Event envelope, store, and type registry (RFC-0001, RFC-0002)
* `core/kernel/` — Deterministic kernel execution layer (RFC-0003)
* `core/projection/` — Projection engine and typed projections (RFC-0004)
* `core/capability/` — Capability registry and discovery (RFC-0005)
* `core/memory/ephemeral.py` — Session-scoped ephemeral memory (RFC-0004)
* `core/memory/durable.py` — Event-sourced durable memory (RFC-0004)
* `core/msgbus/bridge.py` — Bridge between bubus events and RFC-0002 envelopes

---

## 6. Event System

### 6.1 Event Envelope

The canonical event envelope implements [RFC-0002](RFC-0002.md):

```python
class AgentRef(BaseModel):
    agent_id: str
    agent_type: str
    runtime_id: str
    instance_id: str

class TraceContext(BaseModel):
    trace_id: str
    span_id: str
    parent_span_id: str | None = None
    depth: int = 0

class SignatureBlock(BaseModel):
    algorithm: str
    public_key_id: str
    signature: str

class EventEnvelope(BaseModel):
    spec_version: str = "1.0.0"
    event_id: str                      # UUIDv7
    event_type: str                    # domain.aggregate.action
    event_version: str = "1.0.0"
    timestamp: datetime                # UTC ISO8601
    producer: AgentRef
    trace: TraceContext
    causation_id: str | None = None
    correlation_id: str | None = None
    idempotency_key: str | None = None
    partition_key: str | None = None
    ttl_ms: int | None = None
    payload: dict[str, Any]
    metadata: dict[str, Any] = {}
    signature: SignatureBlock | None = None
```

### 6.2 Domain Event Types

Domain events extend a typed base:

```python
class DomainEvent(BaseModel, ABC):
    """Typed domain event that produces an EventEnvelope."""

    @abstractmethod
    def event_type(self) -> str: ...

    @abstractmethod
    def payload(self) -> dict[str, Any]: ...

    def to_envelope(
        self,
        producer: AgentRef,
        trace: TraceContext,
        causation_id: str | None = None,
        correlation_id: str | None = None,
    ) -> EventEnvelope: ...
```

Standard domain events:

| Event Type | Class | Description |
|------------|-------|-------------|
| `agent.started` | `AgentStarted` | Agent kernel initialized |
| `agent.heartbeat` | `AgentHeartbeat` | Liveness signal |
| `agent.stopped` | `AgentStopped` | Agent kernel shutdown |
| `kernel.node.entered` | `NodeEntered` | Kernel entered a graph node |
| `kernel.node.completed` | `NodeCompleted` | Kernel completed a graph node |
| `kernel.checkpoint.created` | `CheckpointCreated` | State checkpoint saved |
| `capability.registered` | `CapabilityRegistered` | New capability declared |
| `capability.invoked` | `CapabilityInvoked` | Capability invocation requested |
| `capability.completed` | `CapabilityCompleted` | Capability execution finished |
| `memory.written` | `MemoryWritten` | Durable memory updated |
| `task.requested` | `TaskRequested` | Delegation task emitted |
| `task.completed` | `TaskCompleted` | Delegated task finished |

### 6.3 Event Store

```python
class EventStore(ABC):
    """Append-only event log per agent."""

    @abstractmethod
    async def append(self, envelope: EventEnvelope) -> None: ...

    @abstractmethod
    async def read(
        self,
        from_offset: int = 0,
        limit: int | None = None,
        event_type: str | None = None,
        correlation_id: str | None = None,
    ) -> list[EventEnvelope]: ...

    @abstractmethod
    async def last_offset(self) -> int: ...

    @abstractmethod
    async def read_by_correlation(self, correlation_id: str) -> list[EventEnvelope]: ...
```

Implementations:

| Implementation | Backend | Use Case |
|----------------|---------|----------|
| `InMemoryEventStore` | Python list | Testing, development |
| `FileEventStore` | JSONL files | Single-process persistence |
| `PostgresEventStore` | PostgreSQL | Production, multi-agent |

### 6.4 Event Bus Bridge

The bridge adapts between bubus `BaseEvent`/`EventBus` and the RFC-0002 `EventEnvelope`:

```python
class EnvelopeBridge:
    """Bidirectional bridge: bubus BaseEvent ↔ EventEnvelope."""

    def __init__(self, event_bus: EventBus, event_store: EventStore): ...

    async def publish(self, envelope: EventEnvelope) -> None:
        """Append to store, then publish to bubus."""
        ...

    async def subscribe(
        self, event_type: str, handler: Callable[[EventEnvelope], Awaitable[None]]
    ) -> None:
        """Subscribe to envelope-typed events on the bus."""
        ...
```

---

## 7. Kernel Execution Layer

### 7.1 Kernel Executor

The kernel executor wraps LangGraph execution with RFC-0003 constraints:

```python
class NodeResult(BaseModel):
    state_delta: dict[str, Any]
    events: list[DomainEvent] = []

class KernelExecutor:
    """Deterministic kernel execution wrapper over LangGraph."""

    def __init__(
        self,
        graph: CompiledStateGraph,
        event_store: EventStore,
        bridge: EnvelopeBridge,
        agent_ref: AgentRef,
    ): ...

    async def execute(
        self,
        initial_state: dict[str, Any],
        config: RunnableConfig | None = None,
    ) -> dict[str, Any]:
        """Execute graph with event emission and checkpointing."""
        ...

    async def resume(
        self,
        checkpoint_id: str,
        event: EventEnvelope | None = None,
    ) -> dict[str, Any]:
        """Resume execution from checkpoint."""
        ...
```

### 7.2 Node Execution Contract

Graph nodes SHOULD follow the pure-function pattern:

```python
async def my_node(state: AgentState) -> dict[str, Any]:
    """
    Node contract:
    - Input: immutable state snapshot
    - Output: state delta dict (partial update)
    - Side effects: ONLY through emitted events in state["_pending_events"]
    """
    ...
    return {
        "field_to_update": new_value,
        "_pending_events": [SomeDomainEvent(...)],
    }
```

For nodes that MUST invoke LLMs or tools (non-deterministic operations), the kernel logs entropy metadata:

```python
@kernel_node(deterministic=False)
async def llm_reasoning_node(state: AgentState) -> dict[str, Any]:
    ...
```

### 7.3 Checkpoint Management

```python
class CheckpointManager:
    """Manages kernel state checkpoints aligned with event boundaries."""

    def __init__(self, store: BaseCheckpointSaver, event_store: EventStore): ...

    async def save(self, state: dict[str, Any], node_id: str) -> str:
        """Save checkpoint and emit CheckpointCreated event."""
        ...

    async def load(self, checkpoint_id: str) -> dict[str, Any]:
        """Load checkpoint state."""
        ...

    async def replay_from(self, checkpoint_id: str) -> dict[str, Any]:
        """Rebuild state by replaying events from checkpoint."""
        ...
```

---

## 8. Projection Layer

### 8.1 Base Projection

```python
class BaseProjection(ABC, Generic[TState]):
    """
    Deterministic fold over event stream (RFC-0004).
    P : (State, Event) → State
    """

    @abstractmethod
    def initial_state(self) -> TState: ...

    @abstractmethod
    def apply(self, state: TState, event: EventEnvelope) -> TState: ...

    def fold(self, events: Iterable[EventEnvelope]) -> TState:
        state = self.initial_state()
        for event in events:
            state = self.apply(state, event)
        return state
```

### 8.2 Projection Engine

```python
class ProjectionEngine:
    """Manages projection lifecycle: build, cache, invalidate."""

    def __init__(self, event_store: EventStore): ...

    def register(self, name: str, projection: BaseProjection) -> None: ...

    async def get_state(self, name: str) -> Any:
        """Compute or return cached projection state."""
        ...

    async def rebuild(self, name: str) -> Any:
        """Force full replay rebuild."""
        ...

    async def apply_event(self, event: EventEnvelope) -> None:
        """Incrementally update all registered projections."""
        ...
```

### 8.3 Projection Categories

| Category | Class | Determinism | Use Case |
|----------|-------|-------------|----------|
| Execution | `ExecutionProjection` | Strict | Workflow state, task graph, retry counters |
| Cognitive | `CognitiveProjection` | Structural | Conversation history, reasoning trace |
| Semantic | `SemanticProjection` | Indexed | Embedding-based retrieval index |

**Execution Projection** constraints:

* MUST be replayable bit-for-bit
* MUST NOT depend on semantic similarity, time, or randomness
* MUST NOT invoke LLM inference

**Semantic Projection** properties:

* Derived from execution/cognitive projection output
* Rebuildable from event log
* Eventually consistent
* May use vector store for indexing

---

## 9. Memory Hierarchy

### 9.1 Ephemeral Memory

```python
class EphemeralMemory:
    """Session-scoped working memory. Cleared on restart."""

    def __init__(self): ...

    def get(self, key: str) -> Any | None: ...
    def set(self, key: str, value: Any) -> None: ...
    def delete(self, key: str) -> None: ...
    def clear(self) -> None: ...
    def keys(self) -> list[str]: ...
```

### 9.2 Durable Memory

```python
class DurableMemory:
    """Event-sourced durable memory (RFC-0004, Section 5.2)."""

    def __init__(
        self,
        event_store: EventStore,
        projection: CognitiveProjection,
    ): ...

    async def write(self, key: str, value: Any, metadata: dict | None = None) -> None:
        """Write memory via MemoryWritten event."""
        ...

    async def read(self, key: str) -> Any | None:
        """Read from projection state."""
        ...

    async def query(self, filter: MemoryFilter) -> list[MemoryItem]: ...

    async def rebuild(self) -> None:
        """Rebuild memory state from event log."""
        ...
```

### 9.3 Semantic Memory

```python
class SemanticMemory:
    """Indexed retrieval layer over durable memory."""

    def __init__(
        self,
        durable: DurableMemory,
        vector_store: BaseVectorStore,
        llm_client: BaseLLMClient,
    ): ...

    async def index(self, key: str, content: str) -> None:
        """Embed and index content."""
        ...

    async def search(self, query: str, top_k: int = 5) -> list[SearchResult]: ...

    async def rebuild_index(self) -> None:
        """Full re-index from durable memory state."""
        ...
```

### 9.4 Memory Integration

The `MemoryManager` composes all three layers:

```python
class MemoryManager:
    """Unified memory interface composing all three layers."""

    def __init__(
        self,
        ephemeral: EphemeralMemory,
        durable: DurableMemory,
        semantic: SemanticMemory | None = None,
    ): ...

    async def store(
        self, key: str, value: Any, durable: bool = True, index: bool = False
    ) -> None: ...

    async def recall(self, key: str) -> Any | None: ...

    async def search(self, query: str, top_k: int = 5) -> list[SearchResult]: ...
```

---

## 10. Capability Registry

### 10.1 Capability Model

```python
class DeterminismClass(str, Enum):
    DETERMINISTIC = "deterministic"
    NONDETERMINISTIC = "nondeterministic"

class SideEffectClass(str, Enum):
    PURE = "pure"
    IDEMPOTENT = "idempotent"
    EXTERNAL = "external"

class LatencyClass(str, Enum):
    FAST = "fast"        # < 100ms
    MEDIUM = "medium"    # < 5s
    SLOW = "slow"        # < 60s
    LONG = "long"        # > 60s

class Capability(BaseModel):
    id: str                                   # namespace.agent.capability
    version: str                              # semver
    input_schema: dict[str, Any]              # JSON Schema
    output_schema: dict[str, Any]             # JSON Schema
    side_effects: SideEffectClass
    latency_class: LatencyClass
    determinism_class: DeterminismClass
    tags: list[str] = []
    required_roles: list[str] = []
    required_scopes: list[str] = []
```

### 10.2 Registry

```python
class CapabilityRegistry:
    """Projection-based capability registry (RFC-0005)."""

    def __init__(self, projection_engine: ProjectionEngine): ...

    async def register(self, agent_ref: AgentRef, capability: Capability) -> None:
        """Emit CapabilityRegistered event."""
        ...

    async def deprecate(self, capability_id: str, reason: str) -> None:
        """Emit CapabilityDeprecated event."""
        ...

    async def find(
        self,
        capability_id: str,
        version_range: str | None = None,
    ) -> list[tuple[AgentRef, Capability]]: ...

    async def find_by_tag(self, tag: str) -> list[tuple[AgentRef, Capability]]: ...

    async def resolve(
        self,
        capability_id: str,
        version_range: str | None = None,
    ) -> tuple[AgentRef, Capability] | None:
        """Deterministic resolution: filter → version check → rank → select."""
        ...
```

### 10.3 Invocation Flow

```
Caller Agent                  Event Bus               Target Agent
     |                            |                        |
     |-- CapabilityInvoked ------>|                        |
     |                            |-- CapabilityInvoked -->|
     |                            |                        |-- execute
     |                            |<-- CapabilityCompleted-|
     |<-- CapabilityCompleted ----|                        |
```

---

## 11. Agent Base Classes

### 11.1 Updated Hierarchy

```
BaseAgent (ABC)
├── Token tracking, LLM client management
├── Event store, projection engine (NEW)
│
├── BaseGraphicAgent(BaseAgent)
│   ├── LangGraph StateGraph
│   ├── KernelExecutor integration (NEW)
│   ├── Capability registration (NEW)
│   │
│   ├── BaseHitlAgent
│   │   ├── Session management
│   │   ├── Human-in-the-loop patterns
│   │   └── DurableMemory per session (NEW)
│   │
│   └── BaseResearcher
│       ├── Research workflow patterns
│       ├── Source management
│       └── Citation tracking
```

### 11.2 BaseAgent Extensions

```python
class BaseAgent(ABC):
    """Extended with event-sourced infrastructure."""

    def __init__(
        self,
        agent_id: str | None = None,
        llm_provider: str | None = None,
        llm_model: str | None = None,
        event_store: EventStore | None = None,    # NEW
    ):
        self.agent_ref = AgentRef(
            agent_id=agent_id or str(uuid7()),
            agent_type=self.__class__.__name__,
            runtime_id=os.getenv("NOESIUM_RUNTIME_ID", "local"),
            instance_id=str(uuid7()),
        )
        self._event_store = event_store or InMemoryEventStore()
        self._projection_engine = ProjectionEngine(self._event_store)
        self._memory = MemoryManager(
            ephemeral=EphemeralMemory(),
            durable=DurableMemory(self._event_store, CognitiveProjection()),
        )
        ...

    @abstractmethod
    async def run(self, input_data: str) -> str: ...

    async def emit_event(self, event: DomainEvent) -> None:
        """Emit domain event through the event system."""
        ...
```

### 11.3 BaseGraphicAgent Extensions

```python
class BaseGraphicAgent(BaseAgent):
    """Extended with kernel executor and capability support."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._kernel: KernelExecutor | None = None
        self._capabilities: list[Capability] = []
        ...

    @abstractmethod
    def _build_graph(self) -> StateGraph: ...

    async def _compile_and_wrap(self) -> KernelExecutor:
        """Compile graph and wrap with kernel executor."""
        graph = self._build_graph()
        compiled = graph.compile(checkpointer=self._checkpointer)
        return KernelExecutor(
            graph=compiled,
            event_store=self._event_store,
            bridge=self._bridge,
            agent_ref=self.agent_ref,
        )

    def declare_capability(self, capability: Capability) -> None:
        """Declare a capability this agent provides."""
        self._capabilities.append(capability)
```

---

## 12. Tool System Integration

### 12.1 Event-Mediated Tool Execution

For strict deterministic mode, tool invocations are event-mediated:

```python
class ToolInvocationRequested(DomainEvent):
    toolkit_name: str
    tool_name: str
    arguments: dict[str, Any]

    def event_type(self) -> str:
        return "tool.invocation.requested"

class ToolInvocationCompleted(DomainEvent):
    toolkit_name: str
    tool_name: str
    result: Any
    error: str | None = None

    def event_type(self) -> str:
        return "tool.invocation.completed"
```

### 12.2 Direct Tool Execution (Pragmatic Mode)

For development and non-strict agents, direct tool invocation remains available through existing Toolify patterns:

```python
toolkit = ToolkitRegistry.create_toolkit("search", config)
tools = toolkit.get_langchain_tools()
```

### 12.3 Execution Mode Configuration

```python
class ExecutionMode(str, Enum):
    STRICT = "strict"        # Full event-mediated, deterministic
    PRAGMATIC = "pragmatic"  # Direct tool calls, events logged
    SANDBOX = "sandbox"      # No constraints, development only
```

---

## 13. Configuration

### 13.1 Agent Configuration

```python
class AgentConfig(BaseModel):
    agent_id: str | None = None
    llm_provider: str = "openai"
    llm_model: str = "gpt-4"
    llm_config: dict[str, Any] = {}
    execution_mode: ExecutionMode = ExecutionMode.PRAGMATIC
    event_store_backend: str = "memory"     # memory | file | postgres
    enable_projections: bool = False
    enable_capabilities: bool = False
    enable_tracing: bool = True
    memory_config: MemoryConfig = MemoryConfig()
```

### 13.2 Framework Configuration

```python
class NoesiumConfig(BaseModel):
    runtime_id: str = "local"
    event_bus_backend: str = "bubus"
    log_level: str = "INFO"
    tracing_enabled: bool = True
    default_execution_mode: ExecutionMode = ExecutionMode.PRAGMATIC
```

---

## 14. Error Handling

### 14.1 Exception Hierarchy

```python
class NoesiumError(Exception):
    """Base exception for all Noesium errors."""

class EventError(NoesiumError):
    """Event system errors."""

class EventValidationError(EventError):
    """Event envelope validation failure."""

class EventStoreError(EventError):
    """Event store read/write failure."""

class KernelError(NoesiumError):
    """Kernel execution errors."""

class NodeExecutionError(KernelError):
    """Graph node execution failure."""

class CheckpointError(KernelError):
    """Checkpoint save/load failure."""

class ProjectionError(NoesiumError):
    """Projection computation errors."""

class CapabilityError(NoesiumError):
    """Capability registry/resolution errors."""

class CapabilityNotFoundError(CapabilityError):
    """No matching capability found."""
```

### 14.2 Error Events

Failures produce events per [RFC-0002, Section 14](RFC-0002.md#14-error-events):

```python
class ErrorOccurred(DomainEvent):
    error_type: str
    message: str
    original_event_id: str | None = None
    stack_trace: str | None = None

    def event_type(self) -> str:
        return "system.error.occurred"
```

---

## 15. Observability

### 15.1 Trace Propagation

Every event carries `TraceContext`. The tracing module integrates with:

* LangGraph callbacks (`NodeLoggingCallback`, `TokenUsageCallback`)
* OpenTelemetry spans (via Opik or direct OTLP)
* Token usage tracking (`TokenUsageTracker`)

### 15.2 Metrics

| Metric | Type | Description |
|--------|------|-------------|
| `noesium.events.emitted` | Counter | Total events emitted |
| `noesium.events.processed` | Counter | Total events processed |
| `noesium.kernel.node.duration` | Histogram | Node execution time |
| `noesium.projection.rebuild.duration` | Histogram | Projection rebuild time |
| `noesium.capability.resolution.duration` | Histogram | Capability resolution time |
| `noesium.llm.tokens.used` | Counter | LLM tokens consumed |

---

## 16. Migration Strategy

### 16.1 Phase 1: Event Infrastructure

* Add `core/event/` module with envelope and store
* Add `EnvelopeBridge` to `core/msgbus/`
* Existing agents continue working unchanged

### 16.2 Phase 2: Kernel Wrapper

* Add `core/kernel/` module
* Wrap `BaseGraphicAgent` graph execution with `KernelExecutor`
* Event emission optional (pragmatic mode)

### 16.3 Phase 3: Projection Layer

* Add `core/projection/` module
* Implement execution and cognitive projections
* Memory system migrated to event-sourced durable memory

### 16.4 Phase 4: Capability Registry

* Add `core/capability/` module
* Agents declare capabilities on startup
* Inter-agent delegation via capability invocation events

---

## 17. Relationship to Other RFCs

* **[RFC-0001](RFC-0001.md)**: This RFC implements the agent kernel, event bus, event store, and projection layer defined abstractly in RFC-0001.
* **[RFC-0002](RFC-0002.md)**: The `EventEnvelope` class directly implements the canonical envelope specification.
* **[RFC-0003](RFC-0003.md)**: The `KernelExecutor` enforces deterministic execution constraints; `NodeResult` formalizes the node execution contract.
* **[RFC-0004](RFC-0004.md)**: The `BaseProjection`, `ProjectionEngine`, and memory hierarchy implement the formal projection and memory model.
* **[RFC-0005](RFC-0005.md)**: The `CapabilityRegistry`, `DiscoveryService`, and `DeterministicResolver` implement the capability registry and discovery protocol.
* **[RFC-1002](RFC-1002.md)**: Concrete LangGraph-based agent implementations that use the infrastructure defined here.

---

## 18. Open Questions

1. Should `ExecutionMode.STRICT` be enforced at the framework level or per-agent?
2. What is the recommended event store backend for single-process development beyond in-memory?
3. Should the `EnvelopeBridge` support multiple concurrent bus backends?
4. How should projection versioning interact with agent versioning?
5. Should capability resolution support weighted load balancing outside strict determinism?

---

## 19. Conclusion

RFC-1001 translates the abstract Noesium architecture into a concrete Python implementation design. By introducing the event system, kernel executor, projection layer, and capability registry as composable modules alongside existing infrastructure, the framework can evolve incrementally from its current pragmatic execution model toward the full event-sourced, deterministic, distributed architecture envisioned in RFC-0001 through RFC-0005.

> The core framework provides the execution substrate; agents provide the cognitive logic.
