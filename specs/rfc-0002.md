# RFC-0002: Event Schema and Envelope Specification

**Status:** Draft
**Author:** Noesium Team
**Depends on:** RFC-0001 (Event-Sourced Multi-Agent Runtime)
**Target Release:** v0.2

---

# 1. Abstract

This RFC defines the canonical Event Schema and Envelope Specification (ESES) for the multi-agent system described in RFC-0001, tailored for deployment on the **bubus** event bus runtime.

The architecture assumes an append-only, asynchronous, in-process or distributed event bus where:

* Events are first-class immutable objects
* Handlers subscribe declaratively by event type
* Dispatch is asynchronous and non-blocking
* Ordering is preserved per logical channel

Within this context, the Event Envelope serves as the **protocol-level contract** above the bus transport. The bus (bubus) is responsible for delivery semantics, while this specification defines:

* Structural schema invariants
* Deterministic replay guarantees
* Cross-agent trace propagation
* Version-safe schema evolution
* Cryptographic verification boundaries

The envelope is intentionally transport-agnostic and runtime-neutral. While bubus provides the execution substrate (dispatching, subscriptions, async execution), the envelope ensures that every emitted event remains:

* Replayable independent of runtime
* Validatable independent of handler implementation
* Auditable independent of storage backend

This specification does NOT define business-level event types (e.g., capability negotiation events). Instead, it defines the immutable structural contract that every event MUST obey before being published to the bus.

By cleanly separating:

* **Bus mechanics** (delivery, async execution, handler routing)
* **Protocol semantics** (identity, causation, trace, versioning)

we ensure that the multi-agent system can evolve, scale, or swap transport layers without breaking deterministic behavior or audit guarantees.

---

# 2. Design Principles

## 2.1 Event-First Architecture

The event log is the system of record. State is a projection.

## 2.2 Immutability

Events are append-only and MUST NEVER be mutated after publication.

## 2.3 Deterministic Replay

Given:

* Identical event sequence
* Identical deterministic capability definitions

The system MUST reproduce identical derived state.

## 2.4 Transport Agnosticism

The envelope MUST be valid across:

* HTTP
* gRPC
* WebSocket
* Message queues (Kafka, NATS, etc.)

Transport metadata MUST NOT alter semantic meaning.

---

# 3. Canonical Event Envelope

Every event MUST conform to the following top-level structure:

```
EventEnvelope {
  spec_version: string
  event_id: string
  event_type: string
  event_version: string
  timestamp: ISO8601
  producer: AgentRef
  trace: TraceContext
  causation_id: string | null
  correlation_id: string | null
  idempotency_key: string | null
  partition_key: string | null
  ttl_ms: integer | null
  payload: object
  metadata: object
  signature: SignatureBlock | null
}
```

---

# 4. Field Semantics

## 4.1 spec_version

Version of this envelope specification.

Enables forward-compatible parsing.

## 4.2 event_id

Globally unique identifier (UUIDv7 RECOMMENDED).

MUST be unique across the entire system.

## 4.3 event_type

Stable, namespaced identifier.

Format:

```
<domain>.<aggregate>.<action>
```

Example:

```
capability.intent.created
```

## 4.4 event_version

Semantic version of the specific event schema.

Allows independent evolution of payload structure.

## 4.5 timestamp

UTC ISO8601 with millisecond precision.

Represents creation time by producer.

---

# 5. Producer Identity

```
AgentRef {
  agent_id: string
  agent_type: string
  runtime_id: string
  instance_id: string
}
```

The combination of runtime_id + instance_id MUST uniquely identify a live process.

---

# 6. Trace Context

```
TraceContext {
  trace_id: string
  span_id: string
  parent_span_id: string | null
  depth: integer
}
```

Rules:

* trace_id MUST remain constant across a full workflow
* span_id MUST be unique per event
* depth MUST increment on delegation

This enables distributed tracing and hierarchical replay.

---

# 7. Causation and Correlation

## 7.1 causation_id

References the event_id that directly caused this event.

Enables reconstruction of causal graphs.

## 7.2 correlation_id

Logical grouping identifier.

All events related to the same high-level task MUST share a correlation_id.

---

# 8. Idempotency and Partitioning

## 8.1 idempotency_key

Optional deduplication key.

Consumers MUST treat events with identical idempotency_key as duplicates within the same producer scope.

## 8.2 partition_key

Determines event stream partition.

Partition strategy MUST guarantee ordering within a single aggregate boundary.

---

# 9. Payload Contract

The payload field contains the business-level event data.

Constraints:

* MUST validate against declared event_version schema
* MUST be self-contained
* MUST NOT depend on out-of-band transport metadata

Payload schemas MUST be JSON Schema Draft 2020-12 compatible.

---

# 10. Metadata

metadata is a free-form object for non-semantic annotations.

Examples:

* compression flag
* experiment tags
* feature flags

Metadata MUST NOT change the deterministic interpretation of payload.

---

# 11. Signature Block

Optional but RECOMMENDED for distributed deployments.

```
SignatureBlock {
  algorithm: string
  public_key_id: string
  signature: string
}
```

Rules:

* Signature MUST cover the canonicalized envelope excluding signature field
* Canonicalization MUST follow RFC 8785 (JSON Canonicalization Scheme)

If signature exists, consumers MUST verify before processing.

---

# 12. Event Ordering Guarantees

Within a partition_key:

* Events MUST be totally ordered
* Consumers MUST process sequentially

Across partitions:

* Ordering is NOT guaranteed
* Causation graph MUST be used for dependency resolution

---

# 13. Schema Evolution Rules

## 13.1 Backward Compatibility

Event changes MUST follow semantic versioning:

* PATCH: additive non-breaking changes
* MINOR: additive fields
* MAJOR: breaking changes

## 13.2 Deprecation Window

Consumers MUST support at least two major versions concurrently.

---

# 14. Error Events

System-level failures MUST also conform to envelope spec.

Example:

```
system.event.validation_failed
```

Errors MUST include:

* original_event_id
* failure_reason
* validation_trace

---

# 15. Replay Semantics

Replay engine MUST:

1. Sort by partition_key and timestamp
2. Respect causation relationships
3. Reconstruct projections deterministically

Non-deterministic events MUST explicitly log entropy sources in payload.

---

# 16. Streaming Extensions

For long-running operations, events MAY include:

```
stream_sequence: integer
stream_final: boolean
```

Streaming MUST preserve ordering guarantees.

---

# 17. Compliance Requirements

An implementation is compliant if:

* All emitted events validate against envelope schema
* Event IDs are globally unique
* Causation and trace context are correctly maintained
* Replay produces identical projections for deterministic flows

---

# 18. Summary

This specification formalizes the structural backbone of the multi-agent system.

By standardizing the event envelope:

* Agents become protocol-compliant peers
* Negotiation and delegation become replayable graphs
* Security can be layered cryptographically
* Observability becomes native to architecture

This RFC establishes the immutable contract upon which all higher-level multi-agent behaviors are constructed.
