# RFC-2003: Tool System Architecture

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: [RFC-0002](RFC-0002.md), [RFC-0003](RFC-0003.md), [RFC-0005](RFC-0005.md)
**Supersedes**: ---
**Kind**: Architecture Design

---

## 1. Abstract

This RFC defines the abstract architecture for the tool system in the Noesium event-driven framework. It establishes a unified tool execution model that integrates built-in toolkits (`noesium.toolkits`), LangChain-ecosystem tools, MCP (Model Context Protocol) servers, and user-defined tools under a single event-wrapped execution layer with capability registration.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* The `AtomicTool` abstraction -- the smallest executable unit
* Tool source taxonomy (built-in, LangChain, MCP, user-defined)
* Event-wrapped tool execution model
* Tool capability registration via RFC-0005 capability registry
* Skill management architecture (tool composition)
* Security and sandboxing principles
* Integration with the agent kernel (RFC-0003)

### 2.2 Non-Goals

* Concrete Python interfaces or module layout (see RFC-2004)
* Specific MCP server implementations
* Individual toolkit internals
* LLM tool-calling prompt engineering

---

## 3. Background & Motivation

Noesium's current tool system (`Toolify`) provides:

- A `ToolkitRegistry` with `@register_toolkit` for auto-discovery
- `BaseToolkit` / `AsyncBaseToolkit` base classes
- `ToolkitConfig` for configuration
- `ToolConverter` for LangChain ↔ MCP format conversion
- 17+ built-in toolkits (search, bash, memory, document, etc.)

However, several gaps exist:

1. **No event trail**: Tool executions produce no events, making them invisible to projections and replay.
2. **No capability declaration**: Tools are not registered with the capability registry, preventing capability-based discovery.
3. **No unified execution**: Different tool sources (built-in, LangChain, MCP) have different call paths with no common execution wrapper.
4. **No skill composition**: No mechanism to compose multiple tools into reusable skill patterns.
5. **No sandboxing model**: All tools execute with full agent permissions.

A unified architecture is needed to:

- Wrap all tool executions in events for observability
- Register tool capabilities for agent discovery
- Provide a single execution interface regardless of tool source
- Support tool composition as "skills"
- Enable security boundaries for tool execution

---

## 4. Design Principles

1. **Source Agnostic**: The execution layer treats all tools identically regardless of source (built-in, LangChain, MCP, user-defined). The agent never knows the tool's origin.

2. **Event-Wrapped Execution**: Every tool invocation MUST emit `tool.invoked` and `tool.completed` (or `tool.failed`) events. This enables audit trails, performance monitoring, and replay.

3. **Capability First**: Every tool MUST register itself as a capability (RFC-0005) with determinism class, side-effect class, and input/output schema. Agents discover tools through the capability registry.

4. **Preserve Existing Toolkits**: The architecture MUST NOT break existing `noesium.toolkits` or their `@register_toolkit` pattern. It wraps them, not replaces them.

5. **Composable Skills**: Multiple tools can be composed into skills -- named, reusable tool pipelines with descriptions and schemas.

---

## 5. Tool Source Taxonomy

### 5.1 Built-in Toolkits

Existing `noesium.toolkits` registered via `@register_toolkit`. Each toolkit exposes a `get_tools_map()` returning `{name: callable}`. These are the primary tool source.

### 5.2 LangChain-Ecosystem Tools

Any `langchain_core.tools.BaseTool` instance. The tool system ingests them via `ToolConverter` and wraps them in the unified execution layer. This includes tools from `langchain_community`, `langchain_experimental`, and third-party packages.

### 5.3 MCP Server Tools

Tools exposed by MCP (Model Context Protocol) servers. The tool system connects to MCP servers, discovers available tools, and wraps them as `AtomicTool` instances. MCP tools are inherently async and communicate via JSON-RPC.

### 5.4 User-Defined Tools

Functions decorated or registered by the end user at runtime. These are simple Python callables with type annotations, automatically converted to the unified tool format.

---

## 6. AtomicTool Abstraction

An `AtomicTool` is the smallest executable unit in the tool system:

| Property | Description |
|----------|-------------|
| `tool_id` | Globally unique identifier |
| `name` | Human-readable name (used in LLM tool-calling) |
| `description` | What the tool does (used in LLM prompts) |
| `input_schema` | JSON Schema of accepted parameters |
| `output_schema` | JSON Schema of return value (optional) |
| `source` | `builtin`, `langchain`, `mcp`, or `user` |
| `determinism_class` | `deterministic` or `nondeterministic` (RFC-0005) |
| `side_effect_class` | `pure`, `idempotent`, or `external` (RFC-0005) |
| `execute(input) -> output` | The callable that performs the action |

Every AtomicTool is also a Capability in the RFC-0005 sense.

---

## 7. Event-Wrapped Execution Model

### 7.1 Execution Lifecycle

Every tool invocation follows this lifecycle:

```
ToolExecutor.run(tool_id, input)
  → emit ToolInvoked event
  → execute tool callable
  → if success: emit ToolCompleted event (with output)
  → if failure: emit ToolFailed event (with error)
  → return output or raise
```

### 7.2 Tool Lifecycle Events

| Event Type | Payload | When |
|------------|---------|------|
| `tool.invoked` | `tool_id`, `tool_name`, `input`, `source` | Before execution starts |
| `tool.completed` | `tool_id`, `tool_name`, `output`, `duration_ms` | After successful execution |
| `tool.failed` | `tool_id`, `tool_name`, `error`, `duration_ms` | After failed execution |
| `tool.registered` | `tool_id`, `name`, `source`, `capabilities` | Tool becomes available |
| `tool.timeout` | `tool_id`, `tool_name`, `timeout_ms` | Tool execution exceeds timeout |

### 7.3 Execution Properties

| Property | Description |
|----------|-------------|
| Timeout | Each tool has a configurable timeout. Default: 30 seconds. |
| Retries | Tools with `side_effect_class=idempotent` MAY be retried automatically. |
| Concurrency | Multiple tools MAY execute concurrently if independent. |
| Cancellation | Long-running tools SHOULD support cancellation via asyncio. |

---

## 8. Tool Capability Registration

Tools register as capabilities via the existing capability registry (RFC-0005):

1. When a toolkit is initialized, the `ToolExecutor` creates an `AtomicTool` for each function in `get_tools_map()`.
2. Each `AtomicTool` registers as a `Capability` with the capability registry, emitting a `CapabilityRegistered` event.
3. Agents discover available tools by querying the capability registry with filters (tags, determinism class, source, etc.).

### 8.1 Tool Tags

Tools are tagged for discovery:

| Tag | Description |
|-----|-------------|
| `source:builtin` | Built-in toolkit tool |
| `source:langchain` | LangChain ecosystem tool |
| `source:mcp` | MCP server tool |
| `source:user` | User-defined tool |
| `category:search` | Search tools |
| `category:code` | Code execution tools |
| `category:file` | File system tools |
| `category:shell` | Shell command tools |
| `category:web` | Web browsing tools |

---

## 9. Skill Composition

### 9.1 What is a Skill?

A **Skill** is a named composition of one or more AtomicTools with a defined input/output contract and execution logic. Skills enable:

- Reusable multi-step tool workflows (e.g., "search then summarize")
- Domain-specific tool bundles (e.g., "research skill" = search + crawl + summarize)
- Abstraction over tool combinations

### 9.2 Skill Structure

| Property | Description |
|----------|-------------|
| `skill_id` | Unique identifier |
| `name` | Human-readable name |
| `description` | What the skill accomplishes |
| `tools` | List of AtomicTool references used |
| `input_schema` | Schema for skill input |
| `output_schema` | Schema for skill output |
| `execute(input) -> output` | Orchestration logic |

### 9.3 Skill vs Toolkit

| Aspect | Toolkit | Skill |
|--------|---------|-------|
| Granularity | Collection of independent tools | Composed tool workflow |
| Registration | `@register_toolkit` | Skill registry |
| Execution | Individual tool calls | Orchestrated multi-tool execution |
| Source | Single source | May combine tools from multiple sources |

---

## 10. Security and Sandboxing

### 10.1 Permission Model

Each tool declares its required permissions:

| Permission | Description |
|------------|-------------|
| `fs:read` | File system read access |
| `fs:write` | File system write access |
| `net:outbound` | Network outbound requests |
| `shell:execute` | Shell command execution |
| `env:read` | Environment variable access |
| `mcp:connect` | MCP server connections |

### 10.2 Execution Context

The `ToolExecutor` creates a `ToolContext` for each invocation containing:

- Agent identity (who is invoking)
- Granted permissions (from agent configuration)
- Working directory (scoped to agent workspace)
- Timeout constraints
- Trace context for event correlation

### 10.3 Policy Enforcement

Before execution, the `ToolExecutor` validates that the invoking agent has the required permissions. If a tool requires `shell:execute` but the agent is in "ask" mode (read-only), execution is denied.

---

## 11. Integration with Agent Kernel

### 11.1 Tool Nodes in LangGraph

In LangGraph-based agents (RFC-1002), tool execution occurs within graph nodes:

1. The LLM output includes a tool call request.
2. The tool node resolves the tool via the capability registry.
3. The `ToolExecutor` runs the tool with event wrapping.
4. The tool output (or error) is returned as a state delta.
5. Emitted events (`tool.invoked`, `tool.completed`) are collected in `_pending_events`.

### 11.2 Deterministic Replay

Since tool executions emit events, the `ExecutionProjection` can track which tools were called, their inputs, outputs, and timing. For deterministic replay:

- Tools with `determinism_class=deterministic` can be replayed from events.
- Tools with `determinism_class=nondeterministic` must be re-executed or have their outputs cached.

---

## 12. Relationship to Other RFCs

* **RFC-0002**: Tool events follow the envelope specification.
* **RFC-0003**: Tool execution is constrained by deterministic kernel rules. Side effects only through events.
* **RFC-0005**: Each tool registers as a capability with determinism/side-effect classification.
* **RFC-1001**: `ToolExecutor` uses `EventStore` and `EnvelopeBridge` for event emission.
* **RFC-1002**: Agent graphs use tool nodes that route through `ToolExecutor`.

---

## 13. Open Questions

* Should MCP tool sessions persist across agent invocations or be per-execution?
* What is the maximum tool output size before truncation is required?
* Should skills support conditional branching or only linear pipelines?

---

## 14. Conclusion

This RFC establishes a unified tool architecture that wraps all tool sources (built-in, LangChain, MCP, user-defined) in a common execution model with event emission and capability registration. By treating tools as capabilities and wrapping their execution in events, the system gains observability, discoverability, and security control without disrupting the existing toolkit ecosystem.

> **A tool is a capability with a callable -- the executor wraps the call, the events tell the story, and the registry enables discovery.**
