# RFC-2002: Memory Implementation Design

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: [RFC-0002](RFC-0002.md), [RFC-1001](RFC-1001.md), [RFC-2001](RFC-2001.md)
**Supersedes**: ---
**Kind**: Implementation Interface Design

---

## 1. Abstract

This RFC defines the concrete Python implementation of the memory management architecture specified in RFC-2001. It specifies the `MemoryProvider` protocol, provider implementations (event-sourced, MemU file-based), the unified `MemoryManager` facade, recall protocol, and memory domain events -- all integrated with the Noesium event system.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Python `MemoryProvider` protocol and abstract base class
* Concrete provider implementations: `EventSourcedProvider`, `MemuProvider`
* Stub interface for `GraphMemoryProvider` (future)
* Unified `MemoryManager` facade with provider routing
* `RecallProtocol` implementation for cross-provider queries
* Memory domain event types
* Module layout and migration path from existing code

### 2.2 Non-Goals

* Vector store or embedding library selection
* MemU internal refactoring (MemU wraps existing code)
* Cross-agent memory sharing implementation
* Graph database selection

---

## 3. Module Structure

```
noesium/core/memory/
├── __init__.py
├── provider.py          # MemoryProvider ABC, ProviderCapabilities, MemoryEntry
├── events.py            # Memory domain events
├── manager.py           # MemoryManager facade (refactored)
├── recall.py            # RecallProtocol, result merging
├── providers/
│   ├── __init__.py
│   ├── working.py       # WorkingMemoryProvider (in-process dict)
│   ├── event_sourced.py # EventSourcedProvider (wraps EventStore + projection)
│   ├── memu.py          # MemuProvider (wraps existing MemU stack)
│   └── graph.py         # GraphMemoryProvider stub
├── ephemeral.py         # (existing, kept for backward compatibility)
├── durable.py           # (existing, kept for backward compatibility)
├── semantic_memory.py   # (existing, kept for backward compatibility)
├── base.py              # (existing BaseMemoryStore, BaseMemoryManager)
├── models.py            # (existing MemoryItem, MemoryFilter, etc.)
└── memu/                # (existing MemU subsystem, unchanged)
```

---

## 4. Core Types

### 4.1 MemoryEntry

```python
class MemoryEntry(BaseModel):
    key: str
    value: Any
    content_type: str = "fact"      # RFC-2001 §7
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=lambda: datetime.now(tz=timezone.utc))
    updated_at: datetime | None = None
    ttl_ms: int | None = None
    provider_id: str | None = None
```

### 4.2 ProviderCapabilities

```python
class MemoryTier(str, Enum):
    WORKING = "working"
    PERSISTENT = "persistent"
    INDEXED = "indexed"

class ProviderCapabilities(BaseModel):
    provider_id: str
    tier: MemoryTier
    supports_search: bool = False
    supports_graph: bool = False
    content_types: list[str] = Field(default_factory=lambda: ["*"])
    read_only: bool = False
```

### 4.3 RecallQuery and RecallResult

```python
class RecallScope(str, Enum):
    WORKING = "working"
    PERSISTENT = "persistent"
    INDEXED = "indexed"
    ALL = "all"

class RecallQuery(BaseModel):
    query: str
    scope: RecallScope = RecallScope.ALL
    content_types: list[str] | None = None
    provider_ids: list[str] | None = None
    limit: int = 10
    metadata_filters: dict[str, Any] = Field(default_factory=dict)

class RecallResult(BaseModel):
    entry: MemoryEntry
    score: float = 1.0
    provider_id: str
    tier: MemoryTier
```

---

## 5. MemoryProvider Protocol

```python
class MemoryProvider(ABC):
    """Abstract base for all memory providers (RFC-2001 §6.1)."""

    @abstractmethod
    def capabilities(self) -> ProviderCapabilities: ...

    @abstractmethod
    async def write(
        self,
        key: str,
        value: Any,
        *,
        content_type: str = "fact",
        metadata: dict[str, Any] | None = None,
    ) -> MemoryEntry: ...

    @abstractmethod
    async def read(self, key: str) -> MemoryEntry | None: ...

    @abstractmethod
    async def delete(self, key: str) -> bool: ...

    @abstractmethod
    async def search(
        self,
        query: str,
        *,
        limit: int = 10,
        content_types: list[str] | None = None,
        metadata_filters: dict[str, Any] | None = None,
    ) -> list[RecallResult]: ...

    @abstractmethod
    async def list_keys(
        self,
        *,
        content_types: list[str] | None = None,
        prefix: str | None = None,
    ) -> list[str]: ...

    async def rebuild(self) -> None:
        """Rebuild derived state. No-op by default."""

    async def close(self) -> None:
        """Release resources. No-op by default."""
```

---

## 6. Provider Implementations

### 6.1 WorkingMemoryProvider

Dict-backed, synchronous, no event emission. Wraps existing `EphemeralMemory`.

```python
class WorkingMemoryProvider(MemoryProvider):
    def __init__(self) -> None:
        self._data: dict[str, MemoryEntry] = {}

    def capabilities(self) -> ProviderCapabilities:
        return ProviderCapabilities(
            provider_id="working",
            tier=MemoryTier.WORKING,
            supports_search=True,  # simple text matching
        )

    async def write(self, key, value, *, content_type="fact", metadata=None):
        entry = MemoryEntry(key=key, value=value, content_type=content_type,
                            metadata=metadata or {}, provider_id="working")
        self._data[key] = entry
        return entry

    async def read(self, key):
        return self._data.get(key)

    async def delete(self, key):
        return self._data.pop(key, None) is not None

    async def search(self, query, *, limit=10, content_types=None, metadata_filters=None):
        # Simple substring matching on str(value)
        results = []
        for entry in self._data.values():
            if content_types and entry.content_type not in content_types:
                continue
            if query.lower() in str(entry.value).lower():
                results.append(RecallResult(
                    entry=entry, score=1.0,
                    provider_id="working", tier=MemoryTier.WORKING,
                ))
        return results[:limit]

    async def list_keys(self, *, content_types=None, prefix=None):
        keys = list(self._data.keys())
        if prefix:
            keys = [k for k in keys if k.startswith(prefix)]
        if content_types:
            keys = [k for k in keys if self._data[k].content_type in content_types]
        return keys
```

### 6.2 EventSourcedProvider

Wraps `EventStore` and `CognitiveProjection`. All writes emit `MemoryWritten` domain events. Reads derive from projection state. Bridges existing `DurableMemory`.

```python
class EventSourcedProvider(MemoryProvider):
    def __init__(
        self,
        event_store: EventStore,
        producer: AgentRef,
        projection: CognitiveProjection | None = None,
        bridge: EnvelopeBridge | None = None,
    ) -> None: ...

    def capabilities(self) -> ProviderCapabilities:
        return ProviderCapabilities(
            provider_id="event_sourced",
            tier=MemoryTier.PERSISTENT,
            supports_search=False,
        )

    async def write(self, key, value, *, content_type="fact", metadata=None):
        event = MemoryWritten(key=key, value=value, value_type=type(value).__name__,
                              content_type=content_type, provider_id="event_sourced")
        envelope = event.to_envelope(producer=self._producer, trace=self._trace)
        await self._store.append(envelope)
        if self._bridge:
            await self._bridge.publish(envelope)
        self._state = self._projection.apply(self._state, envelope)
        return MemoryEntry(key=key, value=value, content_type=content_type,
                           metadata=metadata or {}, provider_id="event_sourced")

    async def read(self, key):
        raw = self._state.get("memory_entries", {}).get(key)
        if raw is None:
            return None
        return MemoryEntry(key=key, value=raw["value"], content_type=raw.get("content_type", "fact"),
                           provider_id="event_sourced")

    async def rebuild(self):
        events = await self._store.read(event_type="memory.written")
        self._state = self._projection.fold(events)
```

### 6.3 MemuProvider

Wraps existing `MemuMemoryStore` / `MemoryAgent`. All writes are forwarded to MemU's file-based pipeline and then a `MemoryWritten` event is emitted for observability.

```python
class MemuProvider(MemoryProvider):
    def __init__(
        self,
        memory_store: MemuMemoryStore,
        event_store: EventStore | None = None,
        producer: AgentRef | None = None,
    ) -> None: ...

    def capabilities(self) -> ProviderCapabilities:
        return ProviderCapabilities(
            provider_id="memu",
            tier=MemoryTier.PERSISTENT,
            supports_search=True,
            content_types=["activity", "profile", "event", "fact", "conversation"],
        )

    async def write(self, key, value, *, content_type="fact", metadata=None):
        item = MemoryItem(id=key, content=str(value), memory_type=content_type,
                          metadata=metadata or {})
        await self._store.add(item)
        if self._event_store and self._producer:
            event = MemoryWritten(key=key, value=value, value_type="text",
                                  content_type=content_type, provider_id="memu")
            envelope = event.to_envelope(producer=self._producer, trace=TraceContext())
            await self._event_store.append(envelope)
        return MemoryEntry(key=key, value=value, content_type=content_type,
                           metadata=metadata or {}, provider_id="memu")

    async def search(self, query, *, limit=10, content_types=None, metadata_filters=None):
        results = await self._store.search(query=query, limit=limit)
        return [RecallResult(
            entry=MemoryEntry(key=r.memory_item.id, value=r.memory_item.content,
                              content_type=r.memory_item.memory_type, provider_id="memu"),
            score=r.relevance_score,
            provider_id="memu",
            tier=MemoryTier.PERSISTENT,
        ) for r in results]
```

### 6.4 GraphMemoryProvider (Stub)

```python
class GraphMemoryProvider(MemoryProvider):
    """Stub for future graph-based memory (RFC-2001 §10)."""

    def capabilities(self) -> ProviderCapabilities:
        return ProviderCapabilities(
            provider_id="graph",
            tier=MemoryTier.PERSISTENT,
            supports_search=True,
            supports_graph=True,
            content_types=["entity"],
        )

    async def add_entity(self, entity_id: str, entity_type: str, properties: dict) -> MemoryEntry:
        raise NotImplementedError("Graph memory provider is not yet implemented")

    async def add_relation(self, source_id: str, target_id: str, relation_type: str, properties: dict | None = None) -> None:
        raise NotImplementedError("Graph memory provider is not yet implemented")

    async def traverse(self, start_id: str, path_pattern: str | None = None, depth: int = 2) -> list[MemoryEntry]:
        raise NotImplementedError("Graph memory provider is not yet implemented")
```

---

## 7. Memory Domain Events

Extend the existing `DomainEvent` types (RFC-1001 §6.2):

```python
class MemoryWritten(DomainEvent):
    key: str
    value: Any
    value_type: str
    content_type: str = "fact"
    provider_id: str = ""
    def event_type(self) -> str: return "memory.written"

class MemoryDeleted(DomainEvent):
    key: str
    provider_id: str = ""
    def event_type(self) -> str: return "memory.deleted"

class MemoryLinked(DomainEvent):
    source_key: str
    target_key: str
    relation: str
    def event_type(self) -> str: return "memory.linked"

class MemoryProviderRegistered(DomainEvent):
    provider_id: str
    tier: str
    capabilities: dict[str, Any]
    def event_type(self) -> str: return "memory.provider.registered"
```

---

## 8. MemoryManager Facade

The refactored `MemoryManager` replaces the existing one, routing operations to registered providers:

```python
class MemoryManager:
    def __init__(
        self,
        providers: list[MemoryProvider] | None = None,
    ) -> None:
        self._providers: dict[str, MemoryProvider] = {}
        for p in (providers or []):
            self.register_provider(p)

    def register_provider(self, provider: MemoryProvider) -> None:
        caps = provider.capabilities()
        self._providers[caps.provider_id] = provider

    def get_provider(self, provider_id: str) -> MemoryProvider:
        return self._providers[provider_id]

    def providers_by_tier(self, tier: MemoryTier) -> list[MemoryProvider]:
        return [p for p in self._providers.values()
                if p.capabilities().tier == tier]

    async def store(
        self,
        key: str,
        value: Any,
        *,
        content_type: str = "fact",
        tier: MemoryTier = MemoryTier.WORKING,
        provider_id: str | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> MemoryEntry:
        if provider_id:
            provider = self.get_provider(provider_id)
        else:
            candidates = self.providers_by_tier(tier)
            if not candidates:
                raise MemoryError(f"No provider for tier {tier}")
            provider = candidates[0]
        return await provider.write(key, value, content_type=content_type, metadata=metadata)

    async def recall(self, query: RecallQuery) -> list[RecallResult]:
        """Unified recall across providers (RFC-2001 §9)."""
        all_results: list[RecallResult] = []
        for provider in self._providers.values():
            caps = provider.capabilities()
            if query.scope != RecallScope.ALL and caps.tier.value != query.scope.value:
                continue
            if query.provider_ids and caps.provider_id not in query.provider_ids:
                continue
            try:
                results = await provider.search(
                    query.query,
                    limit=query.limit,
                    content_types=query.content_types,
                    metadata_filters=query.metadata_filters or None,
                )
                all_results.extend(results)
            except NotImplementedError:
                continue
        return _merge_results(all_results, limit=query.limit)

    async def read(self, key: str, provider_id: str | None = None) -> MemoryEntry | None:
        if provider_id:
            return await self.get_provider(provider_id).read(key)
        for tier in [MemoryTier.WORKING, MemoryTier.PERSISTENT, MemoryTier.INDEXED]:
            for provider in self.providers_by_tier(tier):
                entry = await provider.read(key)
                if entry is not None:
                    return entry
        return None

    async def close(self) -> None:
        for provider in self._providers.values():
            await provider.close()


def _merge_results(results: list[RecallResult], limit: int) -> list[RecallResult]:
    seen: dict[str, RecallResult] = {}
    for r in results:
        existing = seen.get(r.entry.key)
        if existing is None or r.score > existing.score:
            seen[r.entry.key] = r
    merged = sorted(seen.values(), key=lambda r: (-_tier_rank(r.tier), -r.score))
    return merged[:limit]


def _tier_rank(tier: MemoryTier) -> int:
    return {MemoryTier.WORKING: 3, MemoryTier.PERSISTENT: 2, MemoryTier.INDEXED: 1}.get(tier, 0)
```

---

## 9. Migration Path

### Phase 1: Additive (no breaking changes)

1. Add `provider.py`, `events.py`, `recall.py`, `providers/` alongside existing files.
2. The existing `EphemeralMemory`, `DurableMemory`, `SemanticMemory`, and `MemoryManager` remain functional.
3. New provider-based `MemoryManager` is exposed under a different import or flag.

### Phase 2: Bridge

1. Wrap existing `EphemeralMemory` inside `WorkingMemoryProvider`.
2. Wrap existing `DurableMemory` inside `EventSourcedProvider`.
3. Wrap existing `MemuMemoryStore` inside `MemuProvider`.
4. Existing agent code transitions to using `MemoryManager.store()` / `MemoryManager.recall()`.

### Phase 3: Deprecation

1. Deprecate direct use of `EphemeralMemory`, `DurableMemory`, `SemanticMemory` classes.
2. Remove the old `MemoryManager` after all agents migrate.
3. Existing files kept as thin compatibility wrappers.

---

## 10. Error Handling

```python
class MemoryError(NoesiumError):
    """Base memory exception."""

class ProviderNotFoundError(MemoryError):
    """Requested provider_id is not registered."""

class ProviderReadOnlyError(MemoryError):
    """Write attempted on a read-only provider."""

class RecallError(MemoryError):
    """Recall query failed across all providers."""
```

---

## 11. Testing Strategy

| Test Level | Coverage |
|------------|----------|
| Unit | Each provider in isolation (WorkingMemoryProvider, EventSourcedProvider, MemuProvider stub) |
| Unit | MemoryManager routing logic, provider registration |
| Unit | RecallProtocol merging and deduplication |
| Unit | Memory domain events serialization |
| Integration | MemoryManager → EventSourcedProvider → EventStore → Projection → recall |
| Integration | MemoryManager → MemuProvider → file system → recall |
| Integration | Multi-provider recall across Working + Persistent |

---

## 12. Relationship to Other RFCs

* **RFC-2001**: This RFC implements the architecture defined in RFC-2001.
* **RFC-1001**: `EventSourcedProvider` builds on `EventStore`, `CognitiveProjection`, and `EnvelopeBridge` from RFC-1001.
* **RFC-0002**: All memory events use `EventEnvelope` format.
* **RFC-0004**: The three-tier model (Working/Persistent/Indexed) derives from RFC-0004's memory hierarchy.

---

## 13. Conclusion

This RFC provides the concrete Python contracts for the memory provider system. By wrapping existing implementations (EphemeralMemory, DurableMemory, MemU) as providers behind a unified protocol, agents gain a single interface for memory access. The phased migration path ensures backward compatibility while enabling new providers (graph, database) through the same abstraction.

> **Providers store, the manager routes, and recall unifies -- the memory system becomes a pluggable service.**
