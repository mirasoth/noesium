# RFC-0005: Capability Registry and Discovery Protocol

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2025-03-01
**Last Updated**: 2025-03-01
**Depends on**: [RFC-0001](RFC-0001.md), [RFC-0002](RFC-0002.md), [RFC-0003](RFC-0003.md), [RFC-0004](RFC-0004.md)
**Supersedes**: ---
**Kind**: Architecture Design

---

## 1. Abstract

This RFC defines the **Capability Registry and Discovery Protocol (CRDP)** for Noesium.

The registry enables:

* Deterministic declaration of agent capabilities
* Typed discovery across agents
* Versioned capability negotiation
* Runtime routing without tight coupling
* Multi-agent composability

The protocol ensures that:

* Capabilities are declared via events
* Discovery is projection-based
* Resolution is deterministic
* Invocation is event-driven
* Agents remain loosely coupled

This forms the **contract layer** between autonomous agents.

---

## 2. Problem Statement

In a multi-agent system:

* Agents need to discover other agents.
* Capabilities evolve over time.
* Invocation must be deterministic and auditable.
* Agents must remain replaceable.

Ad-hoc routing leads to:

* Tight coupling
* Hidden dependencies
* Runtime ambiguity
* Non-deterministic behavior

Noesium requires a formal capability model.

---

## 3. Design Principles

1. Capabilities are declared, not inferred.
2. Capability metadata is immutable and versioned.
3. Discovery is projection-based and replayable.
4. Invocation is event-mediated.
5. Resolution must be deterministic inside the Kernel.
6. Registry state must be reconstructable from events.

---

## 4. Conceptual Model

### 4.1 Capability Definition

A capability is a typed contract:

```
Capability C = {
    id: string,
    version: semver,
    input_schema: JSONSchema,
    output_schema: JSONSchema,
    side_effects: enum,
    latency_class: enum,
    determinism_class: enum
}
```

Where:

* `determinism_class ∈ {deterministic, nondeterministic}`
* `side_effects ∈ {pure, idempotent, external}`

---

### 4.2 Agent Capability Set

Each agent A declares:

```
Capabilities_A = {C1, C2, C3}
```

Declared through event emission:

```
CapabilityRegistered
CapabilityDeprecated
CapabilityUpdated
```

---

### 4.3 Registry as Projection

The registry is not a database table.

It is a projection:

```
RegistryState = fold(P_registry, ∅, EventStream)
```

Where:

```
P_registry : (State, Event) → State
```

Constraints:

* Pure function
* Deterministic
* No IO
* Replayable

Aligned with RFC-0003 and RFC-0004.

---

## 5. Event Schema

All events follow RFC-0002 envelope.

### 5.1 CapabilityRegistered

```
{
  "event_type": "capability.registered",
  "agent_id": "agent-X",
  "capability_id": "summarize.text",
  "version": "1.2.0",
  "input_schema": {...},
  "output_schema": {...},
  "metadata": {...}
}
```

---

### 5.2 CapabilityDeprecated

```
{
  "event_type": "capability.deprecated",
  "capability_id": "...",
  "reason": "..."
}
```

---

### 5.3 CapabilityInvoked

```
{
  "event_type": "capability.invoked",
  "caller_agent_id": "...",
  "target_agent_id": "...",
  "capability_id": "...",
  "correlation_id": "..."
}
```

---

## 6. Discovery Protocol

### 6.1 Deterministic Query Model

Discovery occurs through deterministic projection queries:

```
Find(CapabilityID, VersionRange)
FindByTag(Tag)
FindByDeterminismClass(Class)
```

These operate on `RegistryState`, not on external services.

---

### 6.2 Resolution Algorithm

When resolving a capability:

1. Filter by ID
2. Filter by version compatibility
3. Filter by health status
4. Apply deterministic ranking
5. Select target agent

Ranking must not depend on:

* Randomness
* Wall clock
* External metrics

Deterministic ranking may use:

* Static priority
* Registration order
* Explicit weight field

---

## 7. Invocation Flow

1. Caller emits `capability.requested`
2. Kernel resolves deterministically
3. Kernel emits `capability.invoked`
4. Target agent consumes event
5. Target emits `capability.completed`

No direct method calls.

All invocations are event-mediated.

---

## 8. Health & Liveness Model

Health is projection-based.

Agents emit:

```
agent.heartbeat
agent.unavailable
agent.recovered
```

Registry projection maintains:

```
HealthState[agent_id]
```

Resolution excludes unhealthy agents.

---

## 9. Capability Namespacing

To avoid collision:

```
namespace.agent.capability
```

Examples:

```
core.memory.snapshot
analysis.text.summarize
system.planner.plan
```

---

## 10. Version Negotiation

Semver rules apply:

* Major mismatch → incompatible
* Minor upgrade → compatible
* Patch upgrade → safe

Negotiation must be deterministic.

If no compatible version:

→ Emit `capability.unresolved`

---

## 11. Security Model

### 11.1 Access Control

Capabilities may declare:

```
required_roles
required_scopes
```

Kernel validates before invocation.

---

### 11.2 Sandboxing

Invocation isolation:

* Agent cannot mutate registry
* Agent cannot bypass event bus
* No direct state mutation

---

## 12. Distributed Registry Model

For multi-node deployments:

Option A: Global event log
Option B: Partitioned registry with CRDT merge

If partitioned:

```
RegistryState = CRDTMerge(RegistryNodeStates)
```

Must converge deterministically.

---

## 13. Failure Modes

| Failure                | Resolution               |
| ---------------------- | ------------------------ |
| Agent crash            | Mark unavailable         |
| Duplicate registration | Idempotent via event ID  |
| Version conflict       | Deterministic resolution |
| Stale snapshot         | Replay                   |

---

## 14. Extensibility

Future additions may include:

* Capability cost modeling
* QoS-aware resolution
* SLA metadata
* Dynamic load balancing
* Marketplace-style scoring

These must not violate deterministic kernel constraints.

---

## 15. Comparison to Existing Systems

Traditional systems:

* Central registry (e.g., service mesh)
* Runtime RPC resolution
* Imperative routing

Noesium:

* Event-sourced registry
* Projection-based discovery
* Deterministic resolution
* Event-mediated invocation
* Fully replayable routing decisions

---

## 16. Guarantees

This RFC guarantees:

* Loose coupling between agents
* Deterministic capability resolution
* Replayable routing
* Version safety
* Health-aware invocation
* Composable multi-agent scaling

---

## 17. Open Questions

1. Should capability invocation support batching?
2. Should dynamic load balancing be allowed outside kernel determinism?
3. How to model economic cost?
4. Should we support capability capability (meta-capabilities)?

---

## 18. Conclusion

RFC-0005 establishes the contract and discovery layer of Noesium.

It transforms:

Agent calls → Event-mediated contracts
Service lookup → Deterministic projection
Dynamic routing → Replayable resolution

This enables a scalable, deterministic, auditable, and composable multi-agent ecosystem.