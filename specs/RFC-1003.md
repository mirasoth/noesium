# RFC-1003: OpenSandbox-Based Multi-User Agent Isolation Architecture

**Status**: Draft
**Authors**: chenxm
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: RFC-0006
**Supersedes**: ---
**Stage**: Core
**Kind**: Implementation Interface Design

---

## 1. Abstract

This RFC specifies the concrete implementation architecture for multi-user agent isolation using OpenSandbox as the execution runtime for subagent tools.

The goal is to provide:

- Strong user isolation via containerized execution
- High execution density with rapid container lifecycle
- Kubernetes-native deployment model
- Policy-controlled tool execution per capability

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

- System architecture with Agent Kernel, Session Workers, and OpenSandbox Executor
- Tool execution flow from ToolCall to EffectResult
- Multi-level isolation model (user, container, filesystem, network)
- Resource governance and limits
- Scalability strategy for Kubernetes deployment
- Security mitigations and failure handling

### 2.2 Non-Goals

This RFC does **not** define:

- OpenSandbox implementation details (external dependency)
- MicroVM-based isolation (future extension)
- Specific container image specifications
- Network policy engine implementation

---

## 3. Background & Motivation

RFC-0006 establishes the architectural requirement for sandboxed subagent execution. This RFC provides the implementation architecture using OpenSandbox as the container-based execution runtime.

Key requirements addressed:

- Translating architectural isolation into concrete container boundaries
- Achieving high density while maintaining security
- Enabling Kubernetes-native scaling
- Providing structured observability for auditing

---

## 4. Design Principles

1. **Container-per-ToolCall**: Each tool execution gets a fresh, isolated container.
2. **Ephemeral by Default**: Containers are destroyed after execution completes.
3. **Policy Enforcement**: Resource limits and network policies are enforced at container level.
4. **Kubernetes Native**: Leverages K8s primitives for scaling, scheduling, and observability.
5. **Defense in Depth**: Multiple isolation layers (namespace, cgroup, seccomp, filesystem).

---

## 5. System Architecture

The system consists of three layers:

### 5.1 Agent Kernel Pod (Control Plane)

Responsibilities:

- ToolCall generation from user requests
- Capability validation against registry
- Subagent dispatch to executor
- Effect graph recording

Kernel remains stateless except for session metadata references.

### 5.2 Session Worker Layer (Logical Isolation)

Each user session is represented as a logical worker maintaining:

- Memory namespace
- Execution stack
- Capability scope
- Rate limit state

Workers may run as:

- Threads within kernel pod
- Dedicated lightweight worker processes

Isolation is logical, not container-based.

### 5.3 OpenSandbox Executor (Data Plane)

OpenSandbox provides:

- Hardened container isolation
- Resource limitation via cgroups
- Seccomp-based syscall filtering
- Namespace isolation (PID, mount, network)

Each ToolCall results in:

1. Temporary sandbox container creation
2. Tool execution inside container
3. Structured output capture
4. Container teardown

---

## 6. Tool Execution Flow

```
User Session → ToolCall → Capability Registry → Sandbox Executor → OpenSandbox
                                                          ↓
EffectResult ← Container Teardown ← Output Capture ← Tool Execution ← Container Create
```

**Step-by-step:**

1. User session produces `ToolCall` specification
2. Capability registry validates permissions per RFC-0005
3. Kernel sends execution request to sandbox executor
4. OpenSandbox creates isolated container with resource limits
5. Tool runs with restricted capabilities
6. Output captured as `EffectResult`
7. Container destroyed immediately after execution

---

## 7. Isolation Model

Isolation is achieved at multiple levels:

### 7.1 User Isolation

- Session memory namespace separation
- Capability scoping per session
- No cross-session state visibility

### 7.2 Container Isolation

- PID namespace isolation
- Mount namespace isolation
- Network namespace isolation
- Cgroup resource limits

### 7.3 Filesystem Strategy

Each sandbox container:

- Mounts ephemeral root filesystem
- Optionally mounts read-only shared assets
- Has no direct host path access
- Write operations confined to container layer

---

## 8. Network Policy

Network access is explicitly defined per tool category:

| Tier | Policy | Use Cases |
|------|--------|-----------|
| **No-Network** | Default deny | Filesystem ops, code execution |
| **Restricted** | Domain allowlist | Specific API calls, known services |
| **Full Access** | Controlled tier | Web search, browsing tools |

Network policy enforced via:

- Namespace isolation
- Egress filtering at container level
- Policy engine integration (e.g., Calico, Cilium)

---

## 9. Resource Governance

Each sandbox container MUST define:

| Resource | Limit Type | Enforcement |
|----------|------------|-------------|
| CPU | Quota (cores) | Cgroup v2 |
| Memory | Hard limit | Cgroup v2, OOM kill |
| Execution Time | Timeout | Container kill |
| File Size | Quota | Filesystem layer |
| Output Size | Limit | Truncation |

Exceeding limits results in forced termination with structured error response.

---

## 10. Scalability Strategy

OpenSandbox enables:

- High container density on worker nodes
- Rapid container creation (<100ms target)
- Kubernetes horizontal pod autoscaling

**Scaling model:**

- Kernel scales independently based on request rate
- Sandbox executor scales as deployment pool
- Warm container pool reduces startup latency

Load balancing performed at execution dispatch layer.

---

## 11. Security Considerations

OpenSandbox relies on host kernel security with container isolation.

**Mitigations:**

- Rootless containers (non-root user inside container)
- Strict seccomp profile (minimal syscall allowlist)
- Read-only root filesystem
- Minimal base images (reduced attack surface)
- No privilege escalation (capabilities dropped)

**For higher-risk workloads:** A future microVM-based tier may be introduced (see Section 14).

---

## 12. Observability

Each ToolCall execution MUST record:

- Container ID
- Resource usage metrics (CPU, memory, duration)
- Exit code and signal
- Execution time
- Output hash for integrity

Logs MUST be tied to session ID for audit trails.

---

## 13. Failure Handling

**Failure modes:**

| Failure | Detection | Response |
|---------|-----------|----------|
| Timeout | Execution time > limit | Container kill, retry policy |
| Memory exceeded | OOM killer | Structured error, no retry |
| Permission denied | Exit code / stderr | Structured error, no retry |
| Sandbox startup failure | Timeout / error | Retry on different node |

All failures MUST produce structured error responses for kernel integration.

---

## 14. Deployment Model

**Kubernetes layout:**

```
┌─────────────────────────────────────────────────────┐
│  agent-kernel deployment                            │
│  - Kernel pods (stateless)                          │
│  - Session workers (logical)                        │
└─────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────┐
│  sandbox-executor deployment                        │
│  - OpenSandbox runtime pods                         │
│  - Warm container pool                              │
└─────────────────────────────────────────────────────┘
```

**Communication:**

- Shared message bus (e.g., NATS, Redis Streams) OR
- RPC layer (e.g., gRPC with load balancing)

Sandbox executor may maintain a warm container pool to reduce startup latency.

---

## 15. Trade-offs

### 15.1 Advantages

- High container density
- Cloud-native Kubernetes integration
- Lower operational overhead
- Rapid scaling

### 15.2 Limitations

- Shared host kernel (weaker than microVM)
- Container escape risks (mitigated via seccomp, rootless)

### 15.3 Suitable Use Cases

- Enterprise deployments
- Controlled multi-tenant environments
- Workloads without adversarial input

---

## 16. Examples

### 16.1 Container Configuration

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sandbox-tool-exec
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
  containers:
  - name: tool-sandbox
    image: opensandbox/minimal:latest
    resources:
      limits:
        cpu: "0.5"
        memory: "256Mi"
      requests:
        cpu: "0.1"
        memory: "64Mi"
    securityContext:
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
    seccompProfile:
      type: Localhost
      localhostProfile: profiles/strict.json
```

### 16.2 Structured Error Response

```json
{
  "tool_id": "shell.execute",
  "exit_code": 137,
  "error": {
    "type": "RESOURCE_LIMIT_EXCEEDED",
    "message": "Container killed due to OOM",
    "details": {
      "memory_limit_mb": 256,
      "memory_used_mb": 258
    }
  },
  "metadata": {
    "container_id": "sb-abc123",
    "duration_ms": 1420,
    "session_id": "sess-xyz789"
  }
}
```

---

## 17. Relationship to Other RFCs

- **RFC-0006**: Implements the sandboxed subagent architecture specified in RFC-0006
- **RFC-0005**: Uses capability registry for permission validation
- **RFC-0003**: Enforces deterministic kernel by isolating all non-deterministic operations

---

## 18. Open Questions

- Should warm container pools be pre-initialized per tool type?
- What is the optimal balance between container density and security margin?
- Should network policy be enforced at executor level or cluster level?

---

## 19. Future Extensions

- **Runtime Selector**: Dynamic selection between container and microVM based on risk tier
- **Risk-Tiered Classification**: Tool categorization by security risk level
- **Snapshot-Based Replay**: Container snapshot support for debugging and replay
- **MicroVM Tier**: Firecracker-based isolation for high-risk workloads

---

## 20. Conclusion

This RFC provides the implementation architecture for OpenSandbox-based multi-user agent isolation. By leveraging Kubernetes-native container orchestration with strict security policies, the system achieves:

- Strong isolation between user sessions
- High execution density and rapid scaling
- Policy-controlled resource governance
- Comprehensive observability for auditing

The container-based approach is suitable for enterprise multi-tenant deployments while maintaining a path to microVM-based isolation for higher-security requirements.

> Container-per-ToolCall with strict resource limits and defense-in-depth security.
