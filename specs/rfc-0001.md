# RFC-0001: Event-Sourced Multi-Agent Kernel Architecture

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2025-03-01
**Last Updated**: 2025-03-01
**Depends on**: ---
**Supersedes**: ---
**Kind**: Conceptual Design

---

## 1. Abstract

This RFC defines the foundational architecture for a distributed, event-sourced, multi-agent system. The design targets long-running, stateful, autonomous agents capable of durable execution, delegation, replayability, and horizontal scaling.

The architecture is based on the following core decision:

> Each agent is implemented as an Event-Sourced Cognitive Kernel.

Rather than layering multiple orchestration frameworks, the system consolidates reasoning, delegation, and execution semantics into a single graph-based kernel per agent. Distribution is handled exclusively through an event bus. State is derived from immutable event logs.

This RFC formalizes the structural model, execution semantics, and scaling approach for this architecture.

---

# 2. Architectural Goals

The system must support:

1. Long-running autonomous agents
2. Infinite or open-ended reasoning loops
3. Durable and resumable execution
4. Distributed multi-agent collaboration
5. Deterministic replayability
6. Horizontal scalability
7. Explicit separation of cognition, transport, and persistence

Non-goals:

* Direct RPC-based agent invocation
* Hidden subagent hierarchies
* Multiple overlapping orchestration layers

---

## 3. Core Principles

### 3.1 Single Execution Authority

Each agent contains exactly one execution authority: the Agent Kernel.

All reasoning, planning, branching, retries, tool invocation, and delegation logic occur inside this kernel.

No external orchestration layer is permitted to mutate agent state.

---

### 3.2 Event-Sourced State

State is not stored as mutable objects.

Instead:

* Every state transition emits an event
* The event log is the source of truth
* Current state is a projection derived from event history

Formally:

State_t = Projection(Event_0 … Event_t)

This ensures:

* Replayability
* Deterministic reconstruction
* Auditable cognition
* Crash recovery

---

### 3.3 Delegation via Events

Delegation is modeled as event emission, not direct invocation.

An agent expresses intent by publishing a task event to a capability topic. Any agent subscribed to that topic may process the task.

This enforces loose coupling and capability-based coordination.

---

### 3.4 Separation of Concerns

Cognition → Agent Kernel
Transport → Event Bus
Persistence → Event Store
Memory Projection → Projection Layer
Capability Routing → Topic Subscriptions

No component duplicates responsibilities of another.

---

## 4. System Architecture

### 4.1 High-Level Topology

```
            Event Bus
                 |
---------------------------------
|                               |
```

Agent Kernel A                Agent Kernel B
|                               |
Event Store A                 Event Store B

Each agent node consists of:

1. Event Subscriber
2. Agent Kernel (graph-based runtime)
3. Event Store
4. Projection Engine
5. Event Publisher

---

## 5. Component Specifications

### 5.1 Event Bus

Responsibilities:

* Topic-based routing
* Delivery guarantees (at-least-once minimum)
* Ordering within partitions
* Backpressure management

The bus is transport-only and contains no business logic.

Acceptable implementations:

* Kafka
* NATS
* Redis Streams

---

### 5.2 Agent Kernel

The Agent Kernel is a deterministic, graph-based execution runtime.

It must support:

* Directed graph execution
* Conditional branching
* Loop constructs
* Retry semantics
* Tool invocation nodes
* Delegation nodes
* Interrupt / approval nodes
* Checkpoint boundaries

The kernel consumes events and produces new events. It does not directly mutate external state.

---

### 5.3 Event Store

Each agent maintains an append-only event log containing:

* Inbound events
* Outbound events
* Internal transition events

Requirements:

* Immutable storage
* Ordered by logical time
* Indexed by event ID and correlation ID

---

### 5.4 Projection Layer

The projection layer derives current agent state from the event log.

Projection examples:

* Active task queue
* Subtask dependency graph
* Pending approvals
* Tool invocation status
* Working memory state

Projections must be deterministic.

---

## 6. Execution Semantics

### 6.1 Event Processing Loop

Each agent continuously executes the following loop:

1. Receive event from bus
2. Append event to local event store
3. Recompute projection (incrementally)
4. Pass event into Agent Kernel
5. Kernel emits zero or more new events
6. Append emitted events locally
7. Publish emitted events to bus

This loop is perpetual.

---

### 6.2 Delegation Flow

Example:

1. Agent A emits TaskRequested(topic="analysis")
2. Agent B subscribes to "analysis"
3. Agent B processes task
4. Agent B emits TaskCompleted
5. Agent A consumes TaskCompleted and continues workflow

No direct call stack spans agents.

---

## 7. Multi-Agent Coordination Model

### 7.1 Capability-Based Routing

Agents declare capabilities by subscribing to topics.

Capabilities are logical, not physical.

Multiple agents may subscribe to the same topic, enabling:

* Load balancing
* Specialization
* Redundancy

---

### 7.2 Correlation and Causality

Each event must include:

* EventID
* CorrelationID
* CausationID
* Timestamp
* AgentID

This enables tracing and distributed workflow reconstruction.

---

## 8. Memory Architecture

Memory is divided into:

1. Working Memory (derived projection)
2. Persistent Semantic Memory (vector store / database)

All memory writes must be event-backed.

No silent state mutation is allowed.

---

## 9. Fault Tolerance

### 9.1 Crash Recovery

On restart:

1. Reload event log
2. Rebuild projections
3. Resume processing from last processed offset

No external coordination is required.

---

### 9.2 Idempotency

Event handlers must be idempotent.

Duplicate event delivery must not produce divergent state.

---

## 10. Scaling Model

Scaling is achieved via:

* Topic partitioning
* Horizontal agent replication
* Capability specialization
* Event partition ownership

Agents are independently deployable units.

---

## 11. Security Model (Preliminary)

Future specification required for:

* Topic-level access control
* Capability authorization
* Agent identity verification
* Event signing

---

## 12. Advantages Over Layered Agent Stacks

* Single orchestration authority per agent
* Deterministic replayable cognition
* No dual delegation systems
* Durable workflow semantics
* Explicit separation of control domains
* Native distributed coordination