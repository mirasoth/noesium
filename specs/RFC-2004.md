# RFC-2004: Tool Implementation Design

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: [RFC-0005](RFC-0005.md), [RFC-1001](RFC-1001.md), [RFC-2003](RFC-2003.md)
**Supersedes**: ---
**Kind**: Implementation Interface Design

---

## 1. Abstract

This RFC defines the concrete Python implementation of the tool system architecture specified in RFC-2003. It specifies the `AtomicTool` class, `ToolExecutor` with event wrapping, `ToolRegistry` for capability-based discovery, MCP client integration, skill composition, and the module layout -- all preserving backward compatibility with existing `noesium.toolkits`.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* Python `AtomicTool` model and `ToolExecutor` class
* `ToolRegistry` integrating with capability registry
* Adapter classes for each tool source (built-in, LangChain, MCP, user)
* `Skill` composition model
* MCP client session management
* Tool domain event types
* Module layout and migration path

### 2.2 Non-Goals

* Individual toolkit implementations (already exist in `noesium/toolkits/`)
* MCP server implementation (we are a client)
* LLM tool-calling prompt design
* Specific skill implementations

---

## 3. Module Structure

```
noesium/core/toolify/
├── __init__.py              # (existing, add new exports)
├── base.py                  # (existing BaseToolkit, AsyncBaseToolkit)
├── config.py                # (existing ToolkitConfig)
├── registry.py              # (existing ToolkitRegistry, @register_toolkit)
├── atomic.py                # AtomicTool model
├── executor.py              # ToolExecutor with event wrapping
├── tool_registry.py         # ToolRegistry (capability-based discovery)
├── events.py                # Tool domain events
├── adapters/
│   ├── __init__.py
│   ├── builtin_adapter.py   # Wraps noesium.toolkits → AtomicTool[]
│   ├── langchain_adapter.py # Wraps langchain BaseTool → AtomicTool[]
│   ├── mcp_adapter.py       # Wraps MCP server tools → AtomicTool[]
│   └── function_adapter.py  # Wraps user callables → AtomicTool
├── skill.py                 # Skill composition model
└── mcp_integration.py       # (existing, extended for session management)
```

---

## 4. Core Types

### 4.1 AtomicTool

```python
class ToolSource(str, Enum):
    BUILTIN = "builtin"
    LANGCHAIN = "langchain"
    MCP = "mcp"
    USER = "user"

class ToolPermission(str, Enum):
    FS_READ = "fs:read"
    FS_WRITE = "fs:write"
    NET_OUTBOUND = "net:outbound"
    SHELL_EXECUTE = "shell:execute"
    ENV_READ = "env:read"
    MCP_CONNECT = "mcp:connect"

class AtomicTool(BaseModel):
    tool_id: str = Field(default_factory=lambda: str(uuid7str()))
    name: str
    description: str
    input_schema: dict[str, Any] = Field(default_factory=dict)
    output_schema: dict[str, Any] | None = None
    source: ToolSource = ToolSource.USER
    determinism_class: DeterminismClass = DeterminismClass.NONDETERMINISTIC
    side_effect_class: SideEffectClass = SideEffectClass.EXTERNAL
    permissions: list[ToolPermission] = Field(default_factory=list)
    timeout_ms: int = 30_000
    tags: list[str] = Field(default_factory=list)
    toolkit_name: str | None = None

    model_config = ConfigDict(arbitrary_types_allowed=True)

    _callable: Callable | None = PrivateAttr(default=None)

    def bind(self, fn: Callable) -> "AtomicTool":
        self._callable = fn
        return self

    async def execute(self, **kwargs: Any) -> Any:
        if self._callable is None:
            raise ToolExecutionError(f"Tool {self.name} has no bound callable")
        if asyncio.iscoroutinefunction(self._callable):
            return await self._callable(**kwargs)
        return self._callable(**kwargs)
```

### 4.2 ToolContext

```python
class ToolContext(BaseModel):
    agent_id: str
    trace: TraceContext
    granted_permissions: list[ToolPermission] = Field(default_factory=list)
    working_directory: str | None = None
    timeout_ms: int = 30_000
```

---

## 5. ToolExecutor

The `ToolExecutor` wraps every tool invocation with events:

```python
class ToolExecutor:
    def __init__(
        self,
        event_store: EventStore | None = None,
        bridge: EnvelopeBridge | None = None,
        producer: AgentRef | None = None,
    ) -> None:
        self._event_store = event_store
        self._bridge = bridge
        self._producer = producer or AgentRef(agent_id="system", agent_type="tool_executor")

    async def run(
        self,
        tool: AtomicTool,
        context: ToolContext,
        **kwargs: Any,
    ) -> Any:
        self._check_permissions(tool, context)

        invoked_event = ToolInvoked(
            tool_id=tool.tool_id, tool_name=tool.name,
            input_data=kwargs, source=tool.source.value,
        )
        await self._emit(invoked_event, context.trace)

        t0 = time.monotonic()
        try:
            result = await asyncio.wait_for(
                tool.execute(**kwargs),
                timeout=tool.timeout_ms / 1000.0,
            )
            duration_ms = int((time.monotonic() - t0) * 1000)

            completed_event = ToolCompleted(
                tool_id=tool.tool_id, tool_name=tool.name,
                output_data=result, duration_ms=duration_ms,
            )
            await self._emit(completed_event, context.trace)
            return result

        except asyncio.TimeoutError:
            duration_ms = int((time.monotonic() - t0) * 1000)
            timeout_event = ToolTimeout(
                tool_id=tool.tool_id, tool_name=tool.name,
                timeout_ms=tool.timeout_ms,
            )
            await self._emit(timeout_event, context.trace)
            raise ToolTimeoutError(f"Tool {tool.name} timed out after {tool.timeout_ms}ms")

        except Exception as e:
            duration_ms = int((time.monotonic() - t0) * 1000)
            failed_event = ToolFailed(
                tool_id=tool.tool_id, tool_name=tool.name,
                error=str(e), duration_ms=duration_ms,
            )
            await self._emit(failed_event, context.trace)
            raise

    def _check_permissions(self, tool: AtomicTool, context: ToolContext) -> None:
        missing = set(tool.permissions) - set(context.granted_permissions)
        if missing:
            raise ToolPermissionError(
                f"Tool {tool.name} requires permissions {missing} "
                f"not granted to agent {context.agent_id}"
            )

    async def _emit(self, event: DomainEvent, trace: TraceContext) -> None:
        if self._event_store is None:
            return
        envelope = event.to_envelope(producer=self._producer, trace=trace)
        await self._event_store.append(envelope)
        if self._bridge:
            await self._bridge.publish(envelope)
```

---

## 6. Tool Domain Events

```python
class ToolInvoked(DomainEvent):
    tool_id: str
    tool_name: str
    input_data: dict[str, Any]
    source: str
    def event_type(self) -> str: return "tool.invoked"

class ToolCompleted(DomainEvent):
    tool_id: str
    tool_name: str
    output_data: Any
    duration_ms: int
    def event_type(self) -> str: return "tool.completed"

class ToolFailed(DomainEvent):
    tool_id: str
    tool_name: str
    error: str
    duration_ms: int
    def event_type(self) -> str: return "tool.failed"

class ToolTimeout(DomainEvent):
    tool_id: str
    tool_name: str
    timeout_ms: int
    def event_type(self) -> str: return "tool.timeout"

class ToolRegistered(DomainEvent):
    tool_id: str
    tool_name: str
    source: str
    capabilities: dict[str, Any]
    def event_type(self) -> str: return "tool.registered"
```

---

## 7. Source Adapters

### 7.1 BuiltinAdapter

Converts existing toolkit functions to `AtomicTool`:

```python
class BuiltinAdapter:
    @staticmethod
    def from_toolkit(
        toolkit: BaseToolkit | AsyncBaseToolkit,
        toolkit_name: str,
    ) -> list[AtomicTool]:
        if isinstance(toolkit, AsyncBaseToolkit):
            tools_map = asyncio.run(toolkit.get_filtered_tools_map())
        else:
            tools_map = toolkit.get_filtered_tools_map()

        atomic_tools = []
        for name, func in tools_map.items():
            schema = _extract_schema(func)
            tool = AtomicTool(
                name=name,
                description=func.__doc__ or f"Tool: {name}",
                input_schema=schema,
                source=ToolSource.BUILTIN,
                toolkit_name=toolkit_name,
                tags=[f"source:builtin", f"toolkit:{toolkit_name}"],
            ).bind(func)
            atomic_tools.append(tool)
        return atomic_tools
```

### 7.2 LangChainAdapter

```python
class LangChainAdapter:
    @staticmethod
    def from_langchain_tool(lc_tool: BaseTool) -> AtomicTool:
        schema = lc_tool.args_schema.model_json_schema() if lc_tool.args_schema else {}
        tool = AtomicTool(
            name=lc_tool.name,
            description=lc_tool.description or "",
            input_schema=schema,
            source=ToolSource.LANGCHAIN,
            tags=["source:langchain"],
        )
        if hasattr(lc_tool, 'ainvoke'):
            tool.bind(lc_tool.ainvoke)
        else:
            tool.bind(lc_tool.invoke)
        return tool

    @staticmethod
    def from_langchain_tools(tools: list[BaseTool]) -> list[AtomicTool]:
        return [LangChainAdapter.from_langchain_tool(t) for t in tools]
```

### 7.3 MCPAdapter

```python
class MCPAdapter:
    def __init__(self, session: MCPSession) -> None:
        self._session = session

    async def discover_tools(self) -> list[AtomicTool]:
        mcp_tools = await self._session.list_tools()
        atomic_tools = []
        for mcp_tool in mcp_tools:
            tool = AtomicTool(
                name=mcp_tool.name,
                description=mcp_tool.description or "",
                input_schema=mcp_tool.inputSchema or {},
                source=ToolSource.MCP,
                permissions=[ToolPermission.MCP_CONNECT],
                tags=["source:mcp", f"mcp_server:{self._session.server_name}"],
            )
            tool.bind(self._make_mcp_caller(mcp_tool.name))
            atomic_tools.append(tool)
        return atomic_tools

    def _make_mcp_caller(self, tool_name: str) -> Callable:
        async def _call(**kwargs: Any) -> Any:
            result = await self._session.call_tool(tool_name, kwargs)
            return result
        return _call
```

### 7.4 FunctionAdapter

```python
class FunctionAdapter:
    @staticmethod
    def from_function(
        func: Callable,
        name: str | None = None,
        description: str | None = None,
        **tool_kwargs: Any,
    ) -> AtomicTool:
        schema = _extract_schema(func)
        tool = AtomicTool(
            name=name or func.__name__,
            description=description or func.__doc__ or "",
            input_schema=schema,
            source=ToolSource.USER,
            tags=["source:user"],
            **tool_kwargs,
        ).bind(func)
        return tool
```

---

## 8. ToolRegistry

The `ToolRegistry` manages tool discovery and integrates with the capability registry:

```python
class ToolRegistry:
    def __init__(
        self,
        capability_registry: CapabilityRegistry | None = None,
    ) -> None:
        self._tools: dict[str, AtomicTool] = {}
        self._by_name: dict[str, AtomicTool] = {}
        self._capability_registry = capability_registry

    def register(self, tool: AtomicTool) -> None:
        self._tools[tool.tool_id] = tool
        self._by_name[tool.name] = tool
        if self._capability_registry:
            cap = Capability(
                capability_id=tool.tool_id,
                name=tool.name,
                description=tool.description,
                determinism=tool.determinism_class,
                side_effect=tool.side_effect_class,
                tags=tool.tags,
                input_schema=tool.input_schema,
            )
            # Register capability (async handled externally)

    def register_many(self, tools: list[AtomicTool]) -> None:
        for tool in tools:
            self.register(tool)

    def get_by_id(self, tool_id: str) -> AtomicTool:
        if tool_id not in self._tools:
            raise ToolNotFoundError(f"Tool {tool_id} not registered")
        return self._tools[tool_id]

    def get_by_name(self, name: str) -> AtomicTool:
        if name not in self._by_name:
            raise ToolNotFoundError(f"Tool {name} not registered")
        return self._by_name[name]

    def list_tools(
        self,
        source: ToolSource | None = None,
        tags: list[str] | None = None,
    ) -> list[AtomicTool]:
        tools = list(self._tools.values())
        if source:
            tools = [t for t in tools if t.source == source]
        if tags:
            tools = [t for t in tools if all(tag in t.tags for tag in tags)]
        return tools

    def load_builtin_toolkits(self) -> None:
        from noesium.core.toolify.registry import ToolkitRegistry
        for name in ToolkitRegistry.list_toolkits():
            try:
                toolkit = ToolkitRegistry.create_toolkit(name)
                atomic_tools = BuiltinAdapter.from_toolkit(toolkit, name)
                self.register_many(atomic_tools)
            except Exception:
                pass  # skip toolkits that fail to initialize

    async def load_mcp_server(self, session: MCPSession) -> list[AtomicTool]:
        adapter = MCPAdapter(session)
        tools = await adapter.discover_tools()
        self.register_many(tools)
        return tools

    def to_langchain_tools(self, names: list[str] | None = None) -> list[BaseTool]:
        tools = self.list_tools() if names is None else [self.get_by_name(n) for n in names]
        return [ToolConverter.function_to_langchain(t._callable, t.name, t.description)
                for t in tools if t._callable]
```

---

## 9. Skill Composition

```python
class Skill(BaseModel):
    skill_id: str = Field(default_factory=lambda: str(uuid7str()))
    name: str
    description: str
    tool_names: list[str]
    input_schema: dict[str, Any] = Field(default_factory=dict)
    output_schema: dict[str, Any] | None = None
    tags: list[str] = Field(default_factory=list)

    _executor_fn: Callable | None = PrivateAttr(default=None)

    def bind_executor(self, fn: Callable) -> "Skill":
        self._executor_fn = fn
        return self

    async def execute(
        self,
        tool_registry: ToolRegistry,
        tool_executor: ToolExecutor,
        context: ToolContext,
        **kwargs: Any,
    ) -> Any:
        if self._executor_fn:
            return await self._executor_fn(
                tool_registry=tool_registry,
                tool_executor=tool_executor,
                context=context,
                **kwargs,
            )
        raise NotImplementedError("Skill has no bound executor")


class SkillRegistry:
    def __init__(self) -> None:
        self._skills: dict[str, Skill] = {}

    def register(self, skill: Skill) -> None:
        self._skills[skill.name] = skill

    def get(self, name: str) -> Skill:
        if name not in self._skills:
            raise SkillNotFoundError(f"Skill {name} not registered")
        return self._skills[name]

    def list_skills(self) -> list[Skill]:
        return list(self._skills.values())
```

---

## 10. Error Handling

```python
class ToolError(NoesiumError):
    """Base tool exception."""

class ToolNotFoundError(ToolError):
    """Tool not found in registry."""

class ToolExecutionError(ToolError):
    """Tool execution failed."""

class ToolTimeoutError(ToolError):
    """Tool execution timed out."""

class ToolPermissionError(ToolError):
    """Insufficient permissions for tool."""

class SkillNotFoundError(ToolError):
    """Skill not found in registry."""
```

---

## 11. Migration Path

### Phase 1: Additive

1. Add `atomic.py`, `executor.py`, `tool_registry.py`, `events.py`, `adapters/`, `skill.py` alongside existing files.
2. Existing `BaseToolkit`, `AsyncBaseToolkit`, `ToolkitRegistry`, `@register_toolkit` remain unchanged.
3. `ToolRegistry.load_builtin_toolkits()` wraps existing toolkits as `AtomicTool` instances.

### Phase 2: Integration

1. Agent base classes gain a `tool_executor: ToolExecutor` field.
2. LangGraph tool nodes route through `ToolExecutor.run()` instead of direct calls.
3. All tool invocations produce events visible in `ExecutionProjection`.

### Phase 3: Enhancement

1. MCP server tools discovered and registered alongside built-in tools.
2. Skills composed and registered for domain-specific workflows.
3. Permission enforcement enabled for sandboxed execution.

---

## 12. Testing Strategy

| Test Level | Coverage |
|------------|----------|
| Unit | AtomicTool creation, binding, execution |
| Unit | ToolExecutor event emission, timeout, permission checking |
| Unit | Each adapter (Builtin, LangChain, Function) |
| Unit | ToolRegistry registration, lookup, filtering |
| Unit | Skill composition and execution |
| Unit | Tool domain events serialization |
| Integration | ToolRegistry → BuiltinAdapter → existing toolkits |
| Integration | ToolExecutor → EventStore → ExecutionProjection |
| Integration | MCPAdapter → mock MCP server → ToolRegistry |

---

## 13. Relationship to Other RFCs

* **RFC-2003**: This RFC implements the architecture defined in RFC-2003.
* **RFC-0005**: Tools register as capabilities with determinism and side-effect classification.
* **RFC-1001**: `ToolExecutor` uses `EventStore` and `EnvelopeBridge` for event emission.
* **RFC-1002**: Agent graph tool nodes delegate to `ToolExecutor`.
* **RFC-0003**: Tool execution respects deterministic kernel constraints.

---

## 14. Conclusion

This RFC provides the concrete Python implementation for the unified tool system. By wrapping existing toolkits, LangChain tools, MCP servers, and user functions as `AtomicTool` instances behind a common `ToolExecutor`, the system gains event-based observability, capability-based discovery, and permission-controlled execution. The phased migration ensures full backward compatibility with the existing `noesium.toolkits` ecosystem.

> **Every tool becomes an AtomicTool, every call gets an event, and every discovery goes through the registry -- the system sees all.**
