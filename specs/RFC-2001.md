# RFC-2001: Memory Management Architecture

**Status**: Draft
**Authors**: Noesium Team
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: [RFC-0001](RFC-0001.md), [RFC-0002](RFC-0002.md), [RFC-0004](RFC-0004.md)
**Supersedes**: ---
**Kind**: Architecture Design

---

## 1. Abstract

This RFC defines the abstract architecture for memory management in the Noesium event-driven framework. It unifies the existing event-sourced memory (RFC-0004) and file-based MemU system into a single Memory Provider model with three tiers: Working Memory, Persistent Memory, and Indexed Memory. It also declares the abstract contract for a future graph-based memory provider.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

* The Memory Provider abstraction and provider registry
* A three-tier memory architecture (Working, Persistent, Indexed)
* Memory content type taxonomy
* Unified recall protocol across providers
* Memory lifecycle events
* Abstract contract for graph-based memory (future)
* Integration with the event system (RFC-0002)

### 2.2 Non-Goals

This RFC does **not** define:

* Concrete Python interfaces or module layout (see RFC-2002)
* Vector store selection or embedding strategies
* MemU internal implementation details
* Cross-agent memory sharing protocol (future RFC)

---

## 3. Background & Motivation

Noesium currently has two disconnected memory stacks:

1. **Event-driven stack** (RFC-0004, RFC-1001): `EphemeralMemory`, `DurableMemory`, `SemanticMemory`, and `MemoryManager` -- built on `EventStore` and projections.
2. **MemU stack**: File-based memory with `MemoryAgent`, `RecallAgent`, category-driven markdown storage, embeddings, and LLM-driven actions (activity extraction, theory of mind, clustering).

Additionally, there is no extension point for graph-based memory (entity-relation stores) which is increasingly important for long-running agents that accumulate structured knowledge.

A unified architecture is needed to:

- Allow agents to use any memory backend through a single interface
- Ensure all persistent writes produce events for observability and replay
- Support new memory backends (graph, database) without changing agent code
- Preserve MemU's rich file-based memory capabilities within the new framework

---

## 4. Design Principles

1. **Provider Abstraction**: All memory backends implement a common `MemoryProvider` contract. Agents interact with memory through this contract, never directly with backends.

2. **Event-First Persistence**: Every persistent memory write MUST emit a `MemoryWritten` event. This enables audit trails, replay, and projection-based reads.

3. **Layered Tiers**: Memory is organized into three tiers with clear responsibilities. Each tier MAY be backed by a different provider.

4. **Open Extension**: New providers (graph, database, cloud) can be added by implementing the provider contract and registering via events.

5. **Recall Unification**: A single recall protocol queries across all providers and merges results by relevance.

---

## 5. Memory Tiers

### 5.1 Working Memory (Tier 1)

Session-scoped, ephemeral memory cleared on agent restart.

| Property | Value |
|----------|-------|
| Scope | Single session / execution |
| Durability | None -- lost on restart |
| Latency | Sub-millisecond |
| Event emission | OPTIONAL (for debugging) |
| Examples | Current conversation context, intermediate reasoning, scratchpad |

Working Memory is always in-process and dict-backed. It requires no IO.

### 5.2 Persistent Memory (Tier 2)

Cross-session durable memory surviving restarts.

| Property | Value |
|----------|-------|
| Scope | Agent lifetime or longer |
| Durability | Guaranteed |
| Latency | Milliseconds to seconds |
| Event emission | REQUIRED for all writes |
| Examples | User profiles, task history, learned facts, research findings |

Persistent Memory MAY be backed by:

- **Event-sourced provider**: Writes to `EventStore`, reads from projections.
- **File-based provider** (MemU): Writes to categorized markdown files with LLM-driven extraction.
- **Graph provider** (future): Writes entity-relation triples.
- **Database provider** (future): Writes to SQL/NoSQL stores.

### 5.3 Indexed Memory (Tier 3)

Semantic search overlay derived from Persistent Memory.

| Property | Value |
|----------|-------|
| Scope | Derived from Tier 2 |
| Durability | Rebuildable from Tier 2 |
| Latency | Tens to hundreds of milliseconds |
| Event emission | OPTIONAL (`MemoryIndexed` for tracking) |
| Examples | Vector-indexed facts, embedding-based retrieval |

Indexed Memory is NEVER the source of truth. It is always rebuildable from the Persistent tier.

---

## 6. Memory Provider Model

### 6.1 Provider Contract

A Memory Provider MUST support:

| Operation | Description |
|-----------|-------------|
| `write(key, value, metadata)` | Store a memory entry |
| `read(key)` | Retrieve a memory entry by key |
| `delete(key)` | Remove a memory entry |
| `search(query, filters, limit)` | Search entries by content or metadata |
| `list_keys(filters)` | List available keys matching filters |
| `rebuild()` | Rebuild internal state (for derived providers) |

All operations MUST be async. Write operations on Persistent providers MUST emit events.

### 6.2 Provider Registry

Providers register themselves with the memory subsystem. Registration follows the same event-driven pattern as capabilities (RFC-0005):

- A `MemoryProviderRegistered` event is emitted when a provider becomes available.
- A projection tracks active providers, their tiers, and capabilities.
- The `MemoryManager` discovers providers through this projection.

### 6.3 Provider Capabilities

Each provider declares:

| Property | Description |
|----------|-------------|
| `provider_id` | Unique identifier |
| `tier` | `working`, `persistent`, or `indexed` |
| `supports_search` | Whether semantic/text search is available |
| `supports_graph` | Whether entity-relation queries are available |
| `content_types` | Which memory content types it handles |

---

## 7. Memory Content Types

Memory entries are classified by content type:

| Type | Description | Source |
|------|-------------|--------|
| `activity` | Agent actions and tool invocations | Automatic from events |
| `profile` | User/agent profile information | MemU extraction or explicit |
| `event` | Notable events and milestones | MemU extraction or explicit |
| `fact` | Learned facts and knowledge | Agent reasoning |
| `conversation` | Conversation history excerpts | Automatic from messages |
| `reasoning` | Reasoning traces and reflections | Agent nodes |
| `research` | Research findings with sources | Research agents |
| `entity` | Named entities and relations (graph) | Graph provider |

Content types are extensible. Providers declare which types they handle.

---

## 8. Memory Lifecycle Events

All memory lifecycle events follow the envelope format (RFC-0002):

| Event Type | Payload | When |
|------------|---------|------|
| `memory.written` | `key`, `value`, `value_type`, `content_type`, `provider_id` | Entry created or updated |
| `memory.deleted` | `key`, `provider_id` | Entry removed |
| `memory.linked` | `source_key`, `target_key`, `relation` | Two entries linked (graph) |
| `memory.indexed` | `key`, `index_type` | Entry added to search index |
| `memory.expired` | `key`, `reason` | Entry removed by TTL or cleanup |
| `memory.provider.registered` | `provider_id`, `tier`, `capabilities` | Provider becomes available |

---

## 9. Unified Recall Protocol

### 9.1 Recall Interface

The recall protocol provides a single query interface across all providers:

```
recall(query, scope, filters) -> MemoryResult[]
```

| Parameter | Description |
|-----------|-------------|
| `query` | Natural language query or key pattern |
| `scope` | Which tiers to search: `working`, `persistent`, `indexed`, or `all` |
| `filters` | Content type, provider, date range, metadata |

### 9.2 Result Merging

When querying multiple providers:

1. Each provider returns scored results.
2. Results are merged by relevance score.
3. Duplicates (same key from different providers) are deduplicated, preferring the highest-tier source.
4. Working Memory results always rank highest for current-session keys.

---

## 10. Graph Memory Contract (Future)

Graph-based memory stores entity-relation triples:

| Concept | Description |
|---------|-------------|
| Entity | Named node with type and properties |
| Relation | Directed edge between entities with type and properties |
| Traversal | Query paths through the graph |

The abstract contract:

| Operation | Description |
|-----------|-------------|
| `add_entity(entity)` | Add or update an entity node |
| `add_relation(source, target, relation_type)` | Add a directed edge |
| `get_entity(entity_id)` | Retrieve an entity |
| `get_relations(entity_id, direction, relation_type)` | Get related entities |
| `traverse(start, path_pattern, depth)` | Graph traversal query |

Graph operations emit `memory.written` events with `content_type=entity` and `memory.linked` events for relations.

---

## 11. MemU as a Memory Provider

MemU (the existing file-based memory system) becomes a Persistent Memory provider:

- `MemuProvider` wraps `MemoryAgent` and `RecallAgent`.
- Writes go through MemU's LLM-driven extraction pipeline, then emit `memory.written` events.
- Reads use MemU's file manager and recall agent.
- MemU's categories (`activity`, `profile`, `event`) map to content types.
- MemU's embedding-based search surfaces through the `search` operation.

This preserves MemU's rich capabilities (LLM extraction, theory of mind, clustering) while integrating it into the unified architecture.

---

## 12. Relationship to Other RFCs

* **RFC-0001**: Memory is part of the event-sourced agent architecture. All persistent writes produce events.
* **RFC-0002**: Memory events follow the envelope specification.
* **RFC-0004**: This RFC supersedes RFC-0004's memory hierarchy with a more extensible provider-based model. The three tiers (ephemeral, durable, semantic) map to (Working, Persistent, Indexed).
* **RFC-1001**: The existing `MemoryManager`, `DurableMemory`, etc. become the event-sourced provider implementation under this architecture.
* **RFC-0005**: Memory providers register like capabilities, enabling discovery.

---

## 13. Open Questions

* Should cross-agent memory sharing use a shared event store or a federated recall protocol?
* Should graph memory support schema enforcement or remain schema-free?
* What is the eviction policy for Working Memory when it exceeds size limits?

---

## 14. Conclusion

This RFC establishes a unified memory architecture that accommodates file-based (MemU), event-sourced, vector-indexed, and future graph-based memory through a common provider abstraction. By requiring event emission for all persistent writes, it ensures observability and replayability. The three-tier model (Working, Persistent, Indexed) provides clear separation of concerns while the unified recall protocol gives agents a single interface for memory access.

> **Memory is a projection over experience -- the provider determines the storage, the events ensure the history, and the recall protocol unifies the access.**
