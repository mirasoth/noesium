# RFC-0006: Agent Kernel and Sandboxed Subagent Model

**Status**: Draft
**Authors**: chenxm
**Created**: 2026-03-01
**Last Updated**: 2026-03-01
**Depends on**: RFC-0003, RFC-0005
**Supersedes**: ---
**Kind**: Architecture Design

---

## 1. Abstract

This RFC defines the architectural abstraction and design principles for the Agent Kernel and its interaction with sandboxed subagent tools in a multi-user AI system.

The design assumes:

- A centralized Agent Kernel
- Logical multi-user isolation within the kernel
- All tool execution occurring in an external sandbox runtime
- Deterministic kernel state transitions
- External effects modeled as first-class entities

This RFC specifies conceptual boundaries, execution semantics, and security invariants.

---

## 2. Scope and Non-Goals

### 2.1 Scope

This RFC defines:

- Agent Kernel architecture and responsibilities
- Sandboxed subagent model for external effect execution
- Deterministic execution boundary between kernel and subagents
- Capability-driven tool invocation protocol
- Security invariants for multi-user isolation
- Effect graph model for auditing and replay

### 2.2 Non-Goals

This RFC does **not** define:

- Specific sandbox implementation details (covered in RFC-1003)
- Orchestration infrastructure
- Web server integration
- Container runtime specifics

These are defined in subsequent implementation RFCs.

---

## 3. Background & Motivation

Modern AI agents must execute tools such as:

- Python code
- Shell commands
- File system operations
- Web queries

These operations are non-deterministic and may be influenced by user prompts. Direct execution within the kernel violates determinism, security, and isolation requirements established in RFC-0003.

Therefore:

> The Agent Kernel MUST remain pure and deterministic.
> All external effects MUST be delegated to sandboxed subagents.

This separation enables:

- Reproducible kernel state transitions
- Strong security isolation between users
- Policy-controlled external access
- Auditable effect history

---

## 4. Design Principles

1. **Kernel Purity**: The kernel handles planning, memory, and orchestration only. No direct I/O.
2. **Explicit Effects**: All external operations are modeled as first-class ToolCall entities.
3. **External Isolation**: Sandboxed subagents enforce security boundaries outside the kernel.
4. **Capability-First**: Capabilities are required primitives, not optional metadata.
5. **Multi-User Safety**: Logical isolation between users is mandatory, not optional.

---

## 5. Core Architectural Model

### 5.1 Agent Kernel

The Agent Kernel is responsible for:

- Planning and reasoning over user requests
- Memory management and projection
- Capability validation via RFC-0005
- Effect graph construction
- Subagent orchestration

The Kernel MUST NOT:

- Execute arbitrary user code
- Access host file systems directly
- Perform uncontrolled network calls

The Kernel is logically multi-tenant, serving multiple user sessions concurrently.

### 5.2 Subagent Model

A Subagent is an isolated execution unit created when the Kernel requires an external effect.

Properties:

- Runs inside sandbox runtime
- Has restricted capability scope
- Has time and resource limits
- Returns structured `EffectResult`

Subagents are ephemeral and destroyed after execution completes.

---

## 6. Deterministic Execution Boundary

Kernel state transitions MUST be deterministic with respect to:

- Input message
- Memory state
- Tool call specification

Non-deterministic behavior (I/O, randomness, network) MUST be encapsulated in a `ToolCall` node and delegated externally.

The Kernel only records:

- Tool specification
- Execution metadata
- Result payload

This ensures the kernel can replay decisions deterministically given the same inputs and effect results.

---

## 7. Capability-Driven Tool Invocation

Tool invocation follows these steps:

1. Kernel produces `ToolCall` specification
2. Capability registry validates request per RFC-0005
3. Subagent is spawned in sandbox
4. Sandbox executes tool with restricted capabilities
5. Structured `EffectResult` is returned
6. Kernel integrates result into memory graph

Capability scope MUST be attached to each `ToolCall` and validated before execution.

---

## 8. Security Invariants

The following MUST hold:

1. **Kernel Code Isolation**: Kernel cannot execute user-provided code directly.
2. **Memory Isolation**: Subagents cannot access kernel memory.
3. **User Isolation**: Subagents cannot access other users' state.
4. **Filesystem Isolation**: Sandbox filesystem must be isolated from host.
5. **Network Policy**: Network access must be policy-controlled per capability.

Violations of these invariants are considered critical security failures.

---

## 9. Multi-User Logical Isolation

Each user session maintains:

- Independent memory namespace
- Independent execution stack
- Independent capability scope

Session state MUST NOT be visible across users.

Kernel-level scheduling must ensure:

- Fairness across sessions
- Rate limiting per session
- Resource quota enforcement

---

## 10. Effect Graph Model

Every external tool execution becomes an `EffectNode` with:

- Input state hash
- Tool specification
- Sandbox execution metadata
- Output payload
- Exit status

This enables:

- **Auditing**: Complete history of external operations
- **Replay**: Deterministic re-execution with recorded results
- **Reasoning**: Structural analysis of non-deterministic events

---

## 11. Resource Governance

Subagents MUST support:

- CPU quota
- Memory limit
- Timeout enforcement
- Filesystem quota
- Network policy

Failure conditions MUST produce structured error responses.

---

## 12. Examples

### 12.1 ToolCall Structure

```
ToolCall {
  tool_id: "fs.read",
  capability: "fs:read:/tmp/data.json",
  input: { path: "/tmp/data.json" },
  timeout_ms: 5000,
  resource_limits: {
    memory_mb: 256,
    cpu_percent: 10
  }
}
```

### 12.2 EffectResult Structure

```
EffectResult {
  tool_id: "fs.read",
  exit_code: 0,
  output: { content: "{...}" },
  metadata: {
    duration_ms: 42,
    memory_used_mb: 18,
    sandbox_id: "sb-abc123"
  }
}
```

---

## 13. Relationship to Other RFCs

- **RFC-0003**: Depends on Deterministic Kernel Execution Constraints for kernel purity requirements
- **RFC-0005**: Depends on Capability Registry for capability validation protocol
- **RFC-1003**: Implementation architecture for OpenSandbox-based subagent execution

---

## 14. Open Questions

- Should subagents support persistent state across invocations for long-running operations?
- What is the appropriate timeout default for different tool categories?

---

## 15. Conclusion

This RFC establishes the architectural foundation for secure, deterministic agent operation with sandboxed tool execution. By separating the pure kernel from effectful subagents, the system achieves:

- Reproducible kernel state transitions
- Strong multi-user isolation
- Policy-controlled external access
- Complete auditability via effect graphs

These properties are essential for production multi-tenant AI agent systems.

> The Agent Kernel MUST remain pure and deterministic. All external effects MUST be delegated to sandboxed subagents.
